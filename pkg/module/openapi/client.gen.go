// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for APIClientConfigIPFilterOp.
const (
	APIClientConfigIPFilterOpAllow APIClientConfigIPFilterOp = "allow"
	APIClientConfigIPFilterOpDeny  APIClientConfigIPFilterOp = "deny"
)

// Defines values for APIClientConfigRequestIPFilterOp.
const (
	APIClientConfigRequestIPFilterOpAllow APIClientConfigRequestIPFilterOp = "allow"
	APIClientConfigRequestIPFilterOpDeny  APIClientConfigRequestIPFilterOp = "deny"
)

// Defines values for AccessPolicyResult0Action.
const (
	AccessPolicyResult0ActionACTIONALLOW           AccessPolicyResult0Action = "ACTION_ALLOW"
	AccessPolicyResult0ActionACTIONALLOWOVERRIDE   AccessPolicyResult0Action = "ACTION_ALLOW_OVERRIDE"
	AccessPolicyResult0ActionACTIONCONTINUE        AccessPolicyResult0Action = "ACTION_CONTINUE"
	AccessPolicyResult0ActionACTIONDENY            AccessPolicyResult0Action = "ACTION_DENY"
	AccessPolicyResult0ActionACTIONDENYANDREDIRECT AccessPolicyResult0Action = "ACTION_DENY_AND_REDIRECT"
	AccessPolicyResult0ActionACTIONDENYOVERRIDE    AccessPolicyResult0Action = "ACTION_DENY_OVERRIDE"
	AccessPolicyResult0ActionACTIONMFAALWAYS       AccessPolicyResult0Action = "ACTION_MFA_ALWAYS"
	AccessPolicyResult0ActionACTIONMFAOVERRIDE     AccessPolicyResult0Action = "ACTION_MFA_OVERRIDE"
	AccessPolicyResult0ActionACTIONMFAPERSESSION   AccessPolicyResult0Action = "ACTION_MFA_PER_SESSION"
	AccessPolicyResult0ActionACTIONREDIRECT        AccessPolicyResult0Action = "ACTION_REDIRECT"
)

// Defines values for AddressType.
const (
	AddressTypeWork AddressType = "work"
)

// Defines values for AllowBlockListInputOutputAccountStatus.
const (
	AllowBlockListInputOutputAccountStatusCompliant    AllowBlockListInputOutputAccountStatus = "compliant"
	AllowBlockListInputOutputAccountStatusNonCompliant AllowBlockListInputOutputAccountStatus = "non_compliant"
	AllowBlockListInputOutputAccountStatusUnmatched    AllowBlockListInputOutputAccountStatus = "unmatched"
)

// Defines values for AttributeMappingJitpOption.
const (
	AttributeMappingJitpOptionALWAYS   AttributeMappingJitpOption = "ALWAYS"
	AttributeMappingJitpOptionCREATE   AttributeMappingJitpOption = "CREATE"
	AttributeMappingJitpOptionDISABLED AttributeMappingJitpOption = "DISABLED"
	AttributeMappingJitpOptionNONE     AttributeMappingJitpOption = "NONE"
)

// Defines values for Attribute0Datatype.
const (
	Attribute0DatatypeBoolean  Attribute0Datatype = "boolean"
	Attribute0DatatypeInteger  Attribute0Datatype = "integer"
	Attribute0DatatypeInteger1 Attribute0Datatype = "integer[]"
	Attribute0DatatypeString   Attribute0Datatype = "string"
	Attribute0DatatypeString1  Attribute0Datatype = "string[]"
)

// Defines values for Attribute0SourceType.
const (
	Attribute0SourceTypeCredential Attribute0SourceType = "credential"
	Attribute0SourceTypeProfile    Attribute0SourceType = "profile"
	Attribute0SourceTypeSchema     Attribute0SourceType = "schema"
	Attribute0SourceTypeStatic     Attribute0SourceType = "static"
)

// Defines values for BulkResultOp.
const (
	BulkResultOpRemove BulkResultOp = "remove"
)

// Defines values for BulkResultResult.
const (
	BulkResultResultFailure BulkResultResult = "failure"
	BulkResultResultSuccess BulkResultResult = "success"
)

// Defines values for CICCustomGroupResponseGroupType.
const (
	CICCustomGroupResponseGroupTypeReserved CICCustomGroupResponseGroupType = "reserved"
	CICCustomGroupResponseGroupTypeStandard CICCustomGroupResponseGroupType = "standard"
)

// Defines values for CICCustomLargeGroupResponseGroupType.
const (
	CICCustomLargeGroupResponseGroupTypeReserved CICCustomLargeGroupResponseGroupType = "reserved"
	CICCustomLargeGroupResponseGroupTypeStandard CICCustomLargeGroupResponseGroupType = "standard"
)

// Defines values for CICCustomUserUserCategory.
const (
	CICCustomUserUserCategoryFederated CICCustomUserUserCategory = "federated"
	CICCustomUserUserCategoryRegular   CICCustomUserUserCategory = "regular"
)

// Defines values for CICCustomUserResponseUserCategory.
const (
	CICCustomUserResponseUserCategoryFederated CICCustomUserResponseUserCategory = "federated"
	CICCustomUserResponseUserCategoryRegular   CICCustomUserResponseUserCategory = "regular"
)

// Defines values for CampaignConfigurationOutputLaunchDate.
const (
	CampaignConfigurationOutputLaunchDateEpoch           CampaignConfigurationOutputLaunchDate = "epoch"
	CampaignConfigurationOutputLaunchDateYyyyMMDdTHHMmSs CampaignConfigurationOutputLaunchDate = "yyyy-MM-dd'T'HH:mm:ss"
)

// Defines values for CampaignConfigurationOutputMitigationActionType.
const (
	CampaignConfigurationOutputMitigationActionTypeNone     CampaignConfigurationOutputMitigationActionType = "none"
	CampaignConfigurationOutputMitigationActionTypeReminder CampaignConfigurationOutputMitigationActionType = "reminder"
)

// Defines values for CampaignConfigurationOutputOverdueAction.
const (
	CampaignConfigurationOutputOverdueActionApproveAll CampaignConfigurationOutputOverdueAction = "approveAll"
	CampaignConfigurationOutputOverdueActionDoNothing  CampaignConfigurationOutputOverdueAction = "doNothing"
	CampaignConfigurationOutputOverdueActionRejectAll  CampaignConfigurationOutputOverdueAction = "rejectAll"
)

// Defines values for CampaignConfigurationOutputPriority.
const (
	CampaignConfigurationOutputPriorityAll    CampaignConfigurationOutputPriority = "all"
	CampaignConfigurationOutputPriorityHigh   CampaignConfigurationOutputPriority = "high"
	CampaignConfigurationOutputPriorityLow    CampaignConfigurationOutputPriority = "low"
	CampaignConfigurationOutputPriorityMedium CampaignConfigurationOutputPriority = "medium"
)

// Defines values for CampaignConfigurationOutputSignOff.
const (
	CampaignConfigurationOutputSignOffAuto      CampaignConfigurationOutputSignOff = "auto"
	CampaignConfigurationOutputSignOffEoc       CampaignConfigurationOutputSignOff = "eoc"
	CampaignConfigurationOutputSignOffManual    CampaignConfigurationOutputSignOff = "manual"
	CampaignConfigurationOutputSignOffNoSignoff CampaignConfigurationOutputSignOff = "no_signoff"
)

// Defines values for CampaignConfigurationOutputType.
const (
	CampaignConfigurationOutputTypeAccount         CampaignConfigurationOutputType = "account"
	CampaignConfigurationOutputTypeAll             CampaignConfigurationOutputType = "all"
	CampaignConfigurationOutputTypeGroupassignment CampaignConfigurationOutputType = "groupassignment"
	CampaignConfigurationOutputTypeUserassignment  CampaignConfigurationOutputType = "userassignment"
)

// Defines values for ClientAuthenticationClientAssertionType.
const (
	ClientAuthenticationClientAssertionTypeUrnIetfParamsOauthClientAssertionTypeJwtBearer ClientAuthenticationClientAssertionType = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
)

// Defines values for DatabaseMetaDataRowIDLifetime.
const (
	DatabaseMetaDataRowIDLifetimeROWIDUNSUPPORTED      DatabaseMetaDataRowIDLifetime = "ROWID_UNSUPPORTED"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDFOREVER     DatabaseMetaDataRowIDLifetime = "ROWID_VALID_FOREVER"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDOTHER       DatabaseMetaDataRowIDLifetime = "ROWID_VALID_OTHER"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDSESSION     DatabaseMetaDataRowIDLifetime = "ROWID_VALID_SESSION"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDTRANSACTION DatabaseMetaDataRowIDLifetime = "ROWID_VALID_TRANSACTION"
)

// Defines values for EmailAddressType.
const (
	EmailAddressTypeWork EmailAddressType = "work"
)

// Defines values for GroupMembersType.
const (
	GroupMembersTypeUser GroupMembersType = "user"
)

// Defines values for GroupMembersResponseType.
const (
	GroupMembersResponseTypeGroup GroupMembersResponseType = "group"
	GroupMembersResponseTypeUser  GroupMembersResponseType = "user"
)

// Defines values for IdentitySourceInstancesDataStatus.
const (
	IdentitySourceInstancesDataStatusConfigured   IdentitySourceInstancesDataStatus = "configured"
	IdentitySourceInstancesDataStatusUnconfigured IdentitySourceInstancesDataStatus = "unconfigured"
)

// Defines values for MetaV2Deactivated.
const (
	MetaV2DeactivatedAPI       MetaV2Deactivated = "api"
	MetaV2DeactivatedCleanup   MetaV2Deactivated = "cleanup"
	MetaV2DeactivatedTimestamp MetaV2Deactivated = "timestamp"
)

// Defines values for Metadata0EnforcementType.
const (
	Metadata0EnforcementTypeAdaptiveNativeAppMobile Metadata0EnforcementType = "adaptiveNativeAppMobile"
	Metadata0EnforcementTypeAdaptiveNativeAppWeb    Metadata0EnforcementType = "adaptiveNativeAppWeb"
	Metadata0EnforcementTypeFedSSO                  Metadata0EnforcementType = "fedSSO"
	Metadata0EnforcementTypeNativeApp               Metadata0EnforcementType = "nativeApp"
	Metadata0EnforcementTypeNativeAppMobile         Metadata0EnforcementType = "nativeAppMobile"
	Metadata0EnforcementTypeNativeAppWeb            Metadata0EnforcementType = "nativeAppWeb"
)

// Defines values for Metadata0Scope.
const (
	Metadata0ScopeAdministrators Metadata0Scope = "administrators"
	Metadata0ScopeDevelopers     Metadata0Scope = "developers"
)

// Defines values for Metadata0State.
const (
	Metadata0StateACTIVE Metadata0State = "ACTIVE"
	Metadata0StateDRAFT  Metadata0State = "DRAFT"
	Metadata0StateDRY    Metadata0State = "DRY"
	Metadata0StateIDLE   Metadata0State = "IDLE"
)

// Defines values for NotificationsNotifyType.
const (
	NotificationsNotifyTypeEMAIL NotificationsNotifyType = "EMAIL"
	NotificationsNotifyTypeNONE  NotificationsNotifyType = "NONE"
)

// Defines values for PatchOperationOp.
const (
	PatchOperationOpRemove PatchOperationOp = "remove"
	PatchOperationOpUpdate PatchOperationOp = "update"
)

// Defines values for PatchOperationResultOp.
const (
	PatchOperationResultOpRemove PatchOperationResultOp = "remove"
	PatchOperationResultOpUpdate PatchOperationResultOp = "update"
)

// Defines values for PatchOperationResultResult.
const (
	PatchOperationResultResultFailure PatchOperationResultResult = "failure"
	PatchOperationResultResultSuccess PatchOperationResultResult = "success"
)

// Defines values for PatchOperation0Op.
const (
	PatchOperation0OpAdd     PatchOperation0Op = "add"
	PatchOperation0OpRemove  PatchOperation0Op = "remove"
	PatchOperation0OpReplace PatchOperation0Op = "replace"
)

// Defines values for PatchSingleAttributeReqModelDatatype.
const (
	PatchSingleAttributeReqModelDatatypeBoolean  PatchSingleAttributeReqModelDatatype = "boolean"
	PatchSingleAttributeReqModelDatatypeInteger  PatchSingleAttributeReqModelDatatype = "integer"
	PatchSingleAttributeReqModelDatatypeInteger1 PatchSingleAttributeReqModelDatatype = "integer[]"
	PatchSingleAttributeReqModelDatatypeString   PatchSingleAttributeReqModelDatatype = "string"
	PatchSingleAttributeReqModelDatatypeString1  PatchSingleAttributeReqModelDatatype = "string[]"
)

// Defines values for PatchSingleAttributeReqModelSourceType.
const (
	PatchSingleAttributeReqModelSourceTypeCredential PatchSingleAttributeReqModelSourceType = "credential"
	PatchSingleAttributeReqModelSourceTypeSchema     PatchSingleAttributeReqModelSourceType = "schema"
	PatchSingleAttributeReqModelSourceTypeStatic     PatchSingleAttributeReqModelSourceType = "static"
)

// Defines values for PhoneNumberType.
const (
	PhoneNumberTypeFax    PhoneNumberType = "fax"
	PhoneNumberTypeHome   PhoneNumberType = "home"
	PhoneNumberTypeMobile PhoneNumberType = "mobile"
	PhoneNumberTypePager  PhoneNumberType = "pager"
	PhoneNumberTypeWork   PhoneNumberType = "work"
)

// Defines values for PlanPackageDeploymentState.
const (
	PlanPackageDeploymentStateARCHIVED         PlanPackageDeploymentState = "ARCHIVED"
	PlanPackageDeploymentStateDEPLOYED         PlanPackageDeploymentState = "DEPLOYED"
	PlanPackageDeploymentStateDEPRECATED       PlanPackageDeploymentState = "DEPRECATED"
	PlanPackageDeploymentStatePENDING          PlanPackageDeploymentState = "PENDING"
	PlanPackageDeploymentStatePUBLISHED        PlanPackageDeploymentState = "PUBLISHED"
	PlanPackageDeploymentStateRETIRED          PlanPackageDeploymentState = "RETIRED"
	PlanPackageDeploymentStateRUNNING          PlanPackageDeploymentState = "RUNNING"
	PlanPackageDeploymentStateSTOPPED          PlanPackageDeploymentState = "STOPPED"
	PlanPackageDeploymentStateSUSPENDED        PlanPackageDeploymentState = "SUSPENDED"
	PlanPackageDeploymentStateTRANSIENTREMOVED PlanPackageDeploymentState = "TRANSIENT_REMOVED"
)

// Defines values for PlanPackageDocumentType.
const (
	PlanPackageDocumentTypeAPIRESOURCE    PlanPackageDocumentType = "APIRESOURCE"
	PlanPackageDocumentTypeAPIVERSION     PlanPackageDocumentType = "APIVERSION"
	PlanPackageDocumentTypePLANVERSION    PlanPackageDocumentType = "PLANVERSION"
	PlanPackageDocumentTypePOLICYTYPE     PlanPackageDocumentType = "POLICYTYPE"
	PlanPackageDocumentTypePRODUCTVERSION PlanPackageDocumentType = "PRODUCTVERSION"
)

// Defines values for PlanPackagePendingDeploymentState.
const (
	PlanPackagePendingDeploymentStateARCHIVE        PlanPackagePendingDeploymentState = "ARCHIVE"
	PlanPackagePendingDeploymentStateDEPRECATE      PlanPackagePendingDeploymentState = "DEPRECATE"
	PlanPackagePendingDeploymentStatePUBLISH        PlanPackagePendingDeploymentState = "PUBLISH"
	PlanPackagePendingDeploymentStateREMOVE         PlanPackagePendingDeploymentState = "REMOVE"
	PlanPackagePendingDeploymentStateREPLACE        PlanPackagePendingDeploymentState = "REPLACE"
	PlanPackagePendingDeploymentStateRESTAGE        PlanPackagePendingDeploymentState = "RESTAGE"
	PlanPackagePendingDeploymentStateRETIRE         PlanPackagePendingDeploymentState = "RETIRE"
	PlanPackagePendingDeploymentStateSTAGEFROMDRAFT PlanPackagePendingDeploymentState = "STAGE_FROM_DRAFT"
	PlanPackagePendingDeploymentStateSUPERSEDE      PlanPackagePendingDeploymentState = "SUPERSEDE"
	PlanPackagePendingDeploymentStateUPDATE         PlanPackagePendingDeploymentState = "UPDATE"
)

// Defines values for PolicyMetadataEnforcementType.
const (
	PolicyMetadataEnforcementTypeAdaptiveNativeAppMobile PolicyMetadataEnforcementType = "adaptiveNativeAppMobile"
	PolicyMetadataEnforcementTypeAdaptiveNativeAppWeb    PolicyMetadataEnforcementType = "adaptiveNativeAppWeb"
	PolicyMetadataEnforcementTypeFedSSO                  PolicyMetadataEnforcementType = "fedSSO"
	PolicyMetadataEnforcementTypeNativeApp               PolicyMetadataEnforcementType = "nativeApp"
	PolicyMetadataEnforcementTypeNativeAppMobile         PolicyMetadataEnforcementType = "nativeAppMobile"
	PolicyMetadataEnforcementTypeNativeAppWeb            PolicyMetadataEnforcementType = "nativeAppWeb"
)

// Defines values for PolicyMetadataScope.
const (
	PolicyMetadataScopeAdministrators PolicyMetadataScope = "administrators"
	PolicyMetadataScopeDevelopers     PolicyMetadataScope = "developers"
)

// Defines values for PolicyMetadataState.
const (
	PolicyMetadataStateACTIVE PolicyMetadataState = "ACTIVE"
	PolicyMetadataStateDRAFT  PolicyMetadataState = "DRAFT"
	PolicyMetadataStateDRY    PolicyMetadataState = "DRY"
	PolicyMetadataStateIDLE   PolicyMetadataState = "IDLE"
)

// Defines values for ServletContextDefaultSessionTrackingModes.
const (
	ServletContextDefaultSessionTrackingModesCOOKIE ServletContextDefaultSessionTrackingModes = "COOKIE"
	ServletContextDefaultSessionTrackingModesSSL    ServletContextDefaultSessionTrackingModes = "SSL"
	ServletContextDefaultSessionTrackingModesURL    ServletContextDefaultSessionTrackingModes = "URL"
)

// Defines values for ServletContextEffectiveSessionTrackingModes.
const (
	ServletContextEffectiveSessionTrackingModesCOOKIE ServletContextEffectiveSessionTrackingModes = "COOKIE"
	ServletContextEffectiveSessionTrackingModesSSL    ServletContextEffectiveSessionTrackingModes = "SSL"
	ServletContextEffectiveSessionTrackingModesURL    ServletContextEffectiveSessionTrackingModes = "URL"
)

// Defines values for ServletRequestDispatcherType.
const (
	ServletRequestDispatcherTypeASYNC   ServletRequestDispatcherType = "ASYNC"
	ServletRequestDispatcherTypeERROR   ServletRequestDispatcherType = "ERROR"
	ServletRequestDispatcherTypeFORWARD ServletRequestDispatcherType = "FORWARD"
	ServletRequestDispatcherTypeINCLUDE ServletRequestDispatcherType = "INCLUDE"
	ServletRequestDispatcherTypeREQUEST ServletRequestDispatcherType = "REQUEST"
)

// Defines values for SubscribeType.
const (
	SubscribeTypeAuthenticated SubscribeType = "authenticated"
	SubscribeTypeCustom        SubscribeType = "custom"
)

// Defines values for TaskListGetResponseStatus.
const (
	TaskListGetResponseStatusApproved  TaskListGetResponseStatus = "approved"
	TaskListGetResponseStatusCancelled TaskListGetResponseStatus = "cancelled"
	TaskListGetResponseStatusPending   TaskListGetResponseStatus = "pending"
	TaskListGetResponseStatusRejected  TaskListGetResponseStatus = "rejected"
)

// Defines values for TaskListGetResponseTaskType.
const (
	TaskListGetResponseTaskTypePlanDeploymentApproval    TaskListGetResponseTaskType = "planDeploymentApproval"
	TaskListGetResponseTaskTypePlanSubscriptionApproval  TaskListGetResponseTaskType = "planSubscriptionApproval"
	TaskListGetResponseTaskTypeProductDeploymentApproval TaskListGetResponseTaskType = "productDeploymentApproval"
)

// Defines values for TokenRequestClientAssertionType.
const (
	TokenRequestClientAssertionTypeUrnIetfParamsOauthClientAssertionTypeJwtBearer TokenRequestClientAssertionType = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
)

// Defines values for TokenRequestGrantType.
const (
	TokenRequestGrantTypeAuthorizationCode                        TokenRequestGrantType = "authorization_code"
	TokenRequestGrantTypeClientCredentials                        TokenRequestGrantType = "client_credentials"
	TokenRequestGrantTypePassword                                 TokenRequestGrantType = "password"
	TokenRequestGrantTypeRefreshToken                             TokenRequestGrantType = "refresh_token"
	TokenRequestGrantTypeUrnIetfParamsOauthGrantTypeTokenExchange TokenRequestGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for ViewType.
const (
	ViewTypeAuthenticated ViewType = "authenticated"
	ViewTypeCustom        ViewType = "custom"
	ViewTypePublic        ViewType = "public"
)

// Defines values for GetGroupsParamsSortOrder.
const (
	GetGroupsParamsSortOrderAscending  GetGroupsParamsSortOrder = "ascending"
	GetGroupsParamsSortOrderDescending GetGroupsParamsSortOrder = "descending"
)

// Defines values for DeleteGroupParamsNotifyType.
const (
	DeleteGroupParamsNotifyTypeEMAIL DeleteGroupParamsNotifyType = "EMAIL"
	DeleteGroupParamsNotifyTypeNONE  DeleteGroupParamsNotifyType = "NONE"
)

// Defines values for GetGroupParamsMembershipType.
const (
	GetGroupParamsMembershipTypeAllNestedUsers           GetGroupParamsMembershipType = "allNestedUsers"
	GetGroupParamsMembershipTypeFirstLevelGroups         GetGroupParamsMembershipType = "firstLevelGroups"
	GetGroupParamsMembershipTypeFirstLevelUsers          GetGroupParamsMembershipType = "firstLevelUsers"
	GetGroupParamsMembershipTypeFirstLevelUsersAndGroups GetGroupParamsMembershipType = "firstLevelUsersAndGroups"
)

// Defines values for GetUsersParamsSortOrder.
const (
	GetUsersParamsSortOrderAscending  GetUsersParamsSortOrder = "ascending"
	GetUsersParamsSortOrderDescending GetUsersParamsSortOrder = "descending"
)

// Defines values for CreateUserParamsUsershouldnotneedtoresetpassword.
const (
	CreateUserParamsUsershouldnotneedtoresetpasswordFalse CreateUserParamsUsershouldnotneedtoresetpassword = "false"
	CreateUserParamsUsershouldnotneedtoresetpasswordTrue  CreateUserParamsUsershouldnotneedtoresetpassword = "true"
)

// Defines values for DeleteUser0ParamsNotifyType.
const (
	DeleteUser0ParamsNotifyTypeEMAIL DeleteUser0ParamsNotifyType = "EMAIL"
	DeleteUser0ParamsNotifyTypeNONE  DeleteUser0ParamsNotifyType = "NONE"
)

// Defines values for PatchUserParamsUsershouldnotneedtoresetpassword.
const (
	PatchUserParamsUsershouldnotneedtoresetpasswordFalse PatchUserParamsUsershouldnotneedtoresetpassword = "false"
	PatchUserParamsUsershouldnotneedtoresetpasswordTrue  PatchUserParamsUsershouldnotneedtoresetpassword = "true"
)

// Defines values for PutUser0ParamsUsershouldnotneedtoresetpassword.
const (
	PutUser0ParamsUsershouldnotneedtoresetpasswordFalse PutUser0ParamsUsershouldnotneedtoresetpassword = "false"
	PutUser0ParamsUsershouldnotneedtoresetpasswordTrue  PutUser0ParamsUsershouldnotneedtoresetpassword = "true"
)

// Defines values for GetInstancesV2ParamsFilter.
const (
	GetInstancesV2ParamsFilterAppscope GetInstancesV2ParamsFilter = "appscope"
	GetInstancesV2ParamsFilterEnduser  GetInstancesV2ParamsFilter = "enduser"
)

// APIClientAdditionalConfig defines model for APIClientAdditionalConfig.
type APIClientAdditionalConfig struct {
	// AllowedClientAssertionVerificationKeys a list of the allowed client assertion verification keys
	AllowedClientAssertionVerificationKeys *[]string `json:"allowedClientAssertionVerificationKeys,omitempty"`

	// ClientAuthMethod the authentication method type
	ClientAuthMethod *string `json:"clientAuthMethod,omitempty"`

	// ValidateClientAssertionJti a Boolean value that indicates whether or not to validate the client assertion JTI
	ValidateClientAssertionJti *bool `json:"validateClientAssertionJti,omitempty"`
}

// APIClientConfig defines model for APIClientConfig.
type APIClientConfig struct {
	AdditionalConfig *APIClientAdditionalConfig `json:"additionalConfig,omitempty"`

	// AdditionalProperties additional properties for the client
	AdditionalProperties *map[string]interface{} `json:"additionalProperties,omitempty"`

	// ClientID the generated client id for authorization
	ClientID *string `json:"clientId,omitempty"`

	// ClientName the friendly name of the client
	ClientName string `json:"clientName"`

	// ClientSecret the generated client secret for authorization
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Description a description of the client
	Description *string `json:"description,omitempty"`

	// Enabled whether or not the client can be used to generate tokens
	Enabled *bool `json:"enabled,omitempty"`

	// Entitlements the list of entitlements assigned to the client
	Entitlements []string `json:"entitlements"`

	// ID the unique id for the client
	ID *string `json:"id,omitempty"`

	// IPFilterOp the operation of the ip filter. The default setting is null, which means that the ip filter is disabled
	IPFilterOp *APIClientConfigIPFilterOp `json:"ipFilterOp,omitempty"`

	// IPFilters the list of ips
	IPFilters *[]string `json:"ipFilters,omitempty"`

	// JwkURI the JSON web key URI endpoint
	JwkURI           *string                    `json:"jwkUri,omitempty"`
	OverrideSettings *APIClientOverrideSettings `json:"overrideSettings,omitempty"`
}

// APIClientConfigIPFilterOp the operation of the ip filter. The default setting is null, which means that the ip filter is disabled
type APIClientConfigIPFilterOp string

// APIClientConfigPaginatedResponseContainer defines model for APIClientConfigPaginatedResponseContainer.
type APIClientConfigPaginatedResponseContainer struct {
	APIClients *[]APIClientConfig `json:"apiClients,omitempty"`
	Count      *int32             `json:"count,omitempty"`
	Limit      *int32             `json:"limit,omitempty"`
	Page       *int32             `json:"page,omitempty"`
	Total      *int32             `json:"total,omitempty"`
}

// APIClientConfigRequest defines model for APIClientConfigRequest.
type APIClientConfigRequest struct {
	AdditionalConfig *APIClientAdditionalConfig `json:"additionalConfig,omitempty"`

	// AdditionalProperties additional properties for the client
	AdditionalProperties *map[string]map[string]interface{} `json:"additionalProperties,omitempty"`

	// ClientID the unique identifier of the client
	ClientID *string `json:"clientId,omitempty"`

	// ClientName the friendly name of the client
	ClientName string `json:"clientName"`

	// ClientSecret the generated client secret for authorization. If unspecified, a random client secret is generated
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Description a description of the client
	Description *string `json:"description,omitempty"`

	// Enabled whether or not the client can be used to generate tokens
	Enabled bool `json:"enabled"`

	// Entitlements the list of entitlements assigned to the client
	Entitlements []string `json:"entitlements"`

	// IPFilterOp the operation of the ip filter. The default setting is null, which means that the ip filter is disabled
	IPFilterOp *APIClientConfigRequestIPFilterOp `json:"ipFilterOp,omitempty"`

	// IPFilters the list of ips
	IPFilters *[]string `json:"ipFilters,omitempty"`

	// JwkURI the JSON web key URI endpoint
	JwkURI           *string                    `json:"jwkUri,omitempty"`
	OverrideSettings *APIClientOverrideSettings `json:"overrideSettings,omitempty"`
}

// APIClientConfigRequestIPFilterOp the operation of the ip filter. The default setting is null, which means that the ip filter is disabled
type APIClientConfigRequestIPFilterOp string

// APIClientOverrideSettings defines model for APIClientOverrideSettings.
type APIClientOverrideSettings struct {
	// RestrictScopes boolean value that determines whether or not to restrict scopes
	RestrictScopes *bool              `json:"restrictScopes,omitempty"`
	Scopes         *[]APIClientScopes `json:"scopes,omitempty"`
}

// APIClientScopes defines model for APIClientScopes.
type APIClientScopes struct {
	// Description a description of the scope
	Description *string `json:"description,omitempty"`

	// Name the name of the scope
	Name *string `json:"name,omitempty"`
}

// AccessPolicyCondition defines model for AccessPolicyCondition.
type AccessPolicyCondition struct {
	Type *string `json:"type,omitempty"`
}

// AccessPolicyRequest The request payload to create or update a policy
type AccessPolicyRequest struct {
	// ContainsFirstFactor Policy contains firstFactor rules or not.
	ContainsFirstFactor *bool `json:"containsFirstFactor,omitempty"`

	// Description The description of the policy
	Description *string `json:"description,omitempty"`

	// Meta Metadata for a access policy
	Meta *Metadata0 `json:"meta,omitempty"`

	// Name The name of the policy
	Name        string               `json:"name"`
	Rules       *[]AccessPolicyRule0 `json:"rules,omitempty"`
	Validations *PolicyValidations   `json:"validations,omitempty"`
}

// AccessPolicyResult0 The result of an access policy
type AccessPolicyResult0 struct {
	Action *AccessPolicyResult0Action `json:"action,omitempty"`

	// AuthnMethods The authentication methods
	AuthnMethods      []string            `json:"authnMethods"`
	ServerSideActions *[]ServerSideAction `json:"serverSideActions,omitempty"`
}

// AccessPolicyResult0Action defines model for AccessPolicyResult0.Action.
type AccessPolicyResult0Action string

// AccessPolicyRule0 An access policy rule
type AccessPolicyRule0 struct {
	// AlwaysRun Should this rule always run
	AlwaysRun  bool                     `json:"alwaysRun"`
	Conditions *[]AccessPolicyCondition `json:"conditions,omitempty"`

	// Description The description of the rule
	Description *string `json:"description,omitempty"`

	// FirstFactor Is this a first factor rule
	FirstFactor bool `json:"firstFactor"`

	// ID The rule identifier
	ID *string `json:"id,omitempty"`

	// Name The name of the rule
	Name string `json:"name"`

	// Result The result of an access policy
	Result *AccessPolicyResult0 `json:"result,omitempty"`
}

// Address defines model for Address.
type Address struct {
	// Country The country name component. Maximum length is 128 characters.
	Country *string `json:"country,omitempty"`

	// Formatted The formatted value of the address. Maximum length is 500 characters.
	Formatted *string `json:"formatted,omitempty"`

	// Locality The city or locality component. Maximum length is 128 characters.
	Locality *string `json:"locality,omitempty"`

	// PostalCode The postal code. Maximum length is 40 characters.
	PostalCode *string `json:"postalCode,omitempty"`

	// Primary Indicates whether this is address is the primary address for correspondence.
	Primary *bool `json:"primary,omitempty"`

	// Region The region. Maximum length is 128 characters.
	Region *string `json:"region,omitempty"`

	// StreetAddress The street address. Maximum length is 128 characters.
	StreetAddress *string `json:"streetAddress,omitempty"`

	// Type A label that indicates the attribute's function; for example, "work" or "home".
	Type *AddressType `json:"type,omitempty"`
}

// AddressType A label that indicates the attribute's function; for example, "work" or "home".
type AddressType string

// AllowBlockListInputOutput Object used to represent an allowlist and blocklist.
type AllowBlockListInputOutput struct {
	// AGroup Specifies if the filter refers to a group. The values are true or false.
	AGroup *bool `json:"aGroup,omitempty"`

	// AccountOwnershipType Account ownership type.
	AccountOwnershipType *string `json:"accountOwnershipType,omitempty"`

	// AccountStatus To filter the account status.
	AccountStatus *AllowBlockListInputOutputAccountStatus `json:"accountStatus,omitempty"`

	// Description Description of group
	Description *string `json:"description,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FamilyName The family name of the user, or the last name in most Western languages. For example, Jensen is the family name from the full name Ms. Barbara J Jensen, PhD.
	FamilyName *string `json:"familyName,omitempty"`

	// Formatted The full name of the user that includes  user name, middle name, and suffix, that are formatted for display.
	Formatted *string `json:"formatted,omitempty"`

	// GivenName The given name of the user, or first name in most Western languages. For example, Barbara is the given name from the full name Ms. Barbara J Jensen, PhD.
	GivenName *string `json:"givenName,omitempty"`

	// ID The user identifier of the user to be filtered.
	ID *string `json:"id,omitempty"`

	// Name The userName or groupName of the user or group.
	Name *string `json:"name,omitempty"`

	// Realm The realm to which the user belongs. It is always "cloudIdentityRealm" for regular users. Maximum length is 240 characters.
	Realm *string `json:"realm,omitempty"`

	// UserType The type of the user. For example, regular, federated.
	UserType *string `json:"userType,omitempty"`
}

// AllowBlockListInputOutputAccountStatus To filter the account status.
type AllowBlockListInputOutputAccountStatus string

// ApplicationV1 defines model for ApplicationV1.
type ApplicationV1 struct {
	Description *string `json:"description,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	ID          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	URL         *string `json:"url,omitempty"`
}

// AsyncContext defines model for AsyncContext.
type AsyncContext struct {
	Request  *ServletRequest  `json:"request,omitempty"`
	Response *ServletResponse `json:"response,omitempty"`
	Timeout  *int64           `json:"timeout,omitempty"`
}

// AttributeMapping defines model for AttributeMapping.
type AttributeMapping struct {
	// AttrID The IBM Security Verify Cloud Directory attribute identifier.
	AttrID string `json:"attrId"`

	// IdsAttrName The external identity source attribute name. Only required if identity source is not Cloud Directory.
	IdsAttrName string `json:"idsAttrName"`

	// JitpOption The IBM Security Verify Cloud Directory attribute identifier.
	JitpOption AttributeMappingJitpOption `json:"jitpOption"`
	PostEval   *PostEval                  `json:"postEval,omitempty"`
}

// AttributeMappingJitpOption The IBM Security Verify Cloud Directory attribute identifier.
type AttributeMappingJitpOption string

// Attribute0 defines model for Attribute_0.
type Attribute0 struct {
	Constraints *Constraints `json:"constraints,omitempty"`

	// CredName The name of the attribute in the login session credentials. Maximum length is 2048 characters
	CredName *string `json:"credName,omitempty"`

	// CredNameOverrides Realm specific name of the attribute in the login session credentials. This property is specified in the form of key-value pairs where the key is the name of the realm  and the value is the name of the attribute used to override the 'credName' property. Maximum length is 2048 characters
	CredNameOverrides *map[string]string `json:"credNameOverrides,omitempty"`

	// CustomProperties Identifies the attribute custom properties that are attached to this attribute
	CustomProperties *map[string]string `json:"customProperties,omitempty"`

	// Datatype The type of derived data that is expected for the attribute. Defaults to string. The integer datatype is used for any numerical value.
	Datatype Attribute0Datatype `json:"datatype"`

	// Description The description of the attribute. Maximum length is 2048 characters
	Description *string   `json:"description,omitempty"`
	Function    *Function `json:"function,omitempty"`

	// ID The unique identifier for the attribute
	ID *string `json:"id,omitempty"`

	// Name The human-readable name of the attribute. Maximum length is 2048 characters
	Name             string            `json:"name"`
	ProfileAttribute *ProfileAttribute `json:"profileAttribute,omitempty"`
	SchemaAttribute  *SchemaAttribute  `json:"schemaAttribute,omitempty"`

	// Scope Identifies whether the attribute is defined globally by the system or specific to the tenant
	Scope *string `json:"scope,omitempty"`

	// SourceType The type of the attribute source from which the attribute value is derived
	SourceType Attribute0SourceType `json:"sourceType"`

	// Tags The tags used to categorize attributes. Maximum number of tags is 25
	Tags *[]string `json:"tags,omitempty"`

	// Value The default value of the attribute. This value also refers to the fixed value for sourceType="static". Maximum length is 2048 characters
	Value *string `json:"value,omitempty"`
}

// Attribute0Datatype The type of derived data that is expected for the attribute. Defaults to string. The integer datatype is used for any numerical value.
type Attribute0Datatype string

// Attribute0SourceType The type of the attribute source from which the attribute value is derived
type Attribute0SourceType string

// BadRequest0 defines model for BadRequest_0.
type BadRequest0 struct {
	// MessageDescription A requester locale-specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// BufferedReader defines model for BufferedReader.
type BufferedReader = map[string]interface{}

// BulkOperation defines model for BulkOperation.
type BulkOperation struct {
	Op   *string `json:"op,omitempty"`
	Path *string `json:"path,omitempty"`
}

// BulkResponse defines model for BulkResponse.
type BulkResponse struct {
	// MessageDescription Requester locale specific descriptive message.
	MessageDescription *string `json:"messageDescription,omitempty"`

	// MessageID The message key identifier.
	MessageID *string       `json:"messageId,omitempty"`
	Results   *[]BulkResult `json:"results,omitempty"`
}

// BulkResult defines model for BulkResult.
type BulkResult struct {
	// Error this field will not be included if the operation was successful
	Error  *string           `json:"error,omitempty"`
	Op     *BulkResultOp     `json:"op,omitempty"`
	Path   *string           `json:"path,omitempty"`
	Result *BulkResultResult `json:"result,omitempty"`
}

// BulkResultOp defines model for BulkResult.Op.
type BulkResultOp string

// BulkResultResult defines model for BulkResult.Result.
type BulkResultResult string

// CICCustomGroup defines model for CICCustomGroup.
type CICCustomGroup struct {
	// Description The description for the group that is being created.
	Description *string `json:"description,omitempty"`

	// Owners A list of owners for the group.  When the scope of an admin role restricts groups, the members of that role can access only those restricted groups and any other groups that they own.  Members of a scoped role are also automatically assigned as the group owner when creating the group by calling the POST /v2.0/Groups API.
	Owners *[]GroupOwner `json:"owners,omitempty"`
}

// CICCustomGroupResponse defines model for CICCustomGroupResponse.
type CICCustomGroupResponse struct {
	// Description The description for the group.
	Description *string `json:"description,omitempty"`

	// GroupType The group type. This value is read-only.
	GroupType *CICCustomGroupResponseGroupType `json:"groupType,omitempty"`

	// MemberStartIndex The start index of members that are returned on the page.
	MemberStartIndex *int32 `json:"memberStartIndex,omitempty"`

	// MembersPerPage Members per page.  For large group support, this property is the count of members returned in the members array.
	MembersPerPage *int32 `json:"membersPerPage,omitempty"`

	// Owners A list of owners for the group.  For large group support, the group ownership is automatically set and enforced when the request has restricted groups that are associated with the access token's user subject identifier.
	Owners *[]GroupOwner `json:"owners,omitempty"`

	// TotalMembers The total number of members that are in the group.
	TotalMembers int32 `json:"totalMembers"`
}

// CICCustomGroupResponseGroupType The group type. This value is read-only.
type CICCustomGroupResponseGroupType string

// CICCustomLargeGroupResponse defines model for CICCustomLargeGroupResponse.
type CICCustomLargeGroupResponse struct {
	// Description The description for the group.
	Description *string `json:"description,omitempty"`

	// GroupType The group type. This value is read-only.
	GroupType *CICCustomLargeGroupResponseGroupType `json:"groupType,omitempty"`

	// TotalMembers The total number of members that are in the group.
	TotalMembers int32 `json:"totalMembers"`
}

// CICCustomLargeGroupResponseGroupType The group type. This value is read-only.
type CICCustomLargeGroupResponseGroupType string

// CICCustomUser defines model for CICCustomUser.
type CICCustomUser struct {
	// AccountExpires The expiration date of the account.  The value is a date and time of the form  yyyy-mm-ddThh:mm:ssZ.  For example, an account expiration of 2021-04-01T16:00:00Z, expires on year 2021, April 1 at 16 hundred hours GMT.  When an account is expired, the account's active flag is set to false to prevent login.The process that checks for expired accounts runs every 15 minutes at the top of the hour in GMT+0 time.
	AccountExpires *string `json:"accountExpires,omitempty"`

	// CustomAttributes The custom attributes for the user. For the GET /Users API, custom attributes can be referenced by using the fully qualified name. The schema URI is urn:ietf:params:scim:schemas:extension:ibm:2.0:User:customAttributes.scimName, where scimName is the SCIM name of the custom schema attribute that was created with the POST /Schema/attributes API.
	CustomAttributes *[]CustomAttribute `json:"customAttributes,omitempty"`

	// Delegate The "ID" of the target entry to which the approval and re-certification records that are assigned to this identity are to be delegated.
	Delegate *string `json:"delegate,omitempty"`

	// EmailVerified The field that indicates the timestamp at which the user's email was verified.
	EmailVerified *int64 `json:"emailVerified,omitempty"`

	// LinkedAccounts The linked accounts for the user.
	LinkedAccounts *[]LinkedAccount `json:"linkedAccounts,omitempty"`

	// Realm The realm to which the user belongs. It is always "cloudIdentityRealm" for regular users. Maximum length is 240 characters.
	Realm *string `json:"realm,omitempty"`

	// TwoFactorAuthentication Indicates whether two factor authentication is required. It defaults to "false" if not provided.
	TwoFactorAuthentication *bool `json:"twoFactorAuthentication,omitempty"`

	// UnqualifiedUserName An unqualified federated user name. This field is read-only.
	UnqualifiedUserName *string `json:"unqualifiedUserName,omitempty"`

	// UserCategory The user category. If not provided, it defaults to "regular".
	UserCategory *CICCustomUserUserCategory `json:"userCategory,omitempty"`
}

// CICCustomUserUserCategory The user category. If not provided, it defaults to "regular".
type CICCustomUserUserCategory string

// CICCustomUserResponse defines model for CICCustomUserResponse.
type CICCustomUserResponse struct {
	// AccountExpires The expiration date of the account.  The value is a date and time of the form  yyyy-mm-ddThh:mm:ssZ.  For example, an account expiration of 2021-04-01T16:00:00Z, expires on year 2021, April 1 at 16 hundred hours GMT.  When an account is expired, the account's active flag is set to false to prevent login.The process that checks for expired accounts runs every 15 minutes at the top of the hour in GMT+0 time.
	AccountExpires *string `json:"accountExpires,omitempty"`

	// CustomAttributes The custom attributes for the user. For the GET /Users API, custom attributes can be referenced by using the fully qualified name. The schema URI is urn:ietf:params:scim:schemas:extension:ibm:2.0:User:customAttributes.scimName, where scimName is the SCIM name of the custom schema attribute that was created with the POST /Schema/attributes API.
	CustomAttributes *[]CustomAttribute `json:"customAttributes,omitempty"`

	// Delegate The "id" of the entry to which approval and re-certification records assigned to this identity will be delegated.
	Delegate *string `json:"delegate,omitempty"`

	// EmailVerified A timestamp that indicates when the user's email was verified.
	EmailVerified *string `json:"emailVerified,omitempty"`

	// LastLogin Indicates the time of the last login for the current user entry.  Value is a date and time of the form yyyy-mm-ddThh:mm:ssZ.
	LastLogin *string `json:"lastLogin,omitempty"`

	// LastLoginRealm Indicates the realm used for the last login for the current user entry.
	LastLoginRealm *string `json:"lastLoginRealm,omitempty"`

	// LastLoginType Indicates the login type used for the last login for the current user entry.
	LastLoginType *string `json:"lastLoginType,omitempty"`

	// LastMFA The last MFAs for the user.
	LastMFA *[]LastMFA `json:"lastMFA,omitempty"`

	// LinkedAccounts The linked accounts for the user.
	LinkedAccounts *[]LinkedAccount `json:"linkedAccounts,omitempty"`

	// PwdAccountLockedTime A field that indicates the timestamp at which the user's password was locked. The value of this field is in milliseconds and is read-only.
	PwdAccountLockedTime *string `json:"pwdAccountLockedTime,omitempty"`

	// PwdChangedTime Indicates the time when the password was changed for the current user entry. This value is read-only.
	PwdChangedTime *string `json:"pwdChangedTime,omitempty"`

	// PwdExpirationWarned A field that indicates the timestamp at which the user's password expiration is set. The value of this field is in milliseconds and is read-only.
	PwdExpirationWarned *string `json:"pwdExpirationWarned,omitempty"`

	// PwdFailureTime A field that indicates a list of timestamps at which the user attempted to log in with the wrong password The value of this field is in milliseconds and is read-only.
	PwdFailureTime *[]string `json:"pwdFailureTime,omitempty"`

	// PwdGraceUseTime A field that indicates a list of timestamps at which the user attempted to see extended or grace time. The value of this field is in milliseconds and is read-only.
	PwdGraceUseTime *[]string `json:"pwdGraceUseTime,omitempty"`

	// PwdReset Indicates whether the password is reset for the current user entry. This value is read-only.
	PwdReset *bool `json:"pwdReset,omitempty"`

	// Realm The realm to which the user belongs. It is always "cloudIdentityRealm" for non-federated users.
	Realm *string `json:"realm,omitempty"`

	// TwoFactorAuthentication Indicates whether two factory authentication is required. It defaults to "false" if not provided.
	TwoFactorAuthentication *bool `json:"twoFactorAuthentication,omitempty"`

	// UnqualifiedUserName An unqualified, federated user name. This field is read-only.
	UnqualifiedUserName *string `json:"unqualifiedUserName,omitempty"`

	// UserCategory The user category.
	UserCategory *CICCustomUserResponseUserCategory `json:"userCategory,omitempty"`
}

// CICCustomUserResponseUserCategory The user category.
type CICCustomUserResponseUserCategory string

// CampaignConfigurationOutput Representation of a campaign configuration for REST APIs
type CampaignConfigurationOutput struct {
	// AllowSupervisorEscalation Allow escalation to the supervisors.
	AllowSupervisorEscalation *bool `json:"allowSupervisorEscalation,omitempty"`

	// Allowlist List of users or groups that are allowed for the certification
	Allowlist    *[]AllowBlockListInputOutput `json:"allowlist,omitempty"`
	Applications *ApplicationV1               `json:"applications,omitempty"`

	// AssociatedPreviewCampaign Representation of a campaign configuration for REST APIs
	AssociatedPreviewCampaign *CampaignConfigurationOutput `json:"associatedPreviewCampaign,omitempty"`

	// AutomaticRefreshContinuousCampaign A flag for a campaign to refresh the existing filter for building dataset. It is valid for continuous campaigns only.
	AutomaticRefreshContinuousCampaign *bool                        `json:"automaticRefreshContinuousCampaign,omitempty"`
	Blacklist                          *[]AllowBlockListInputOutput `json:"blacklist,omitempty"`

	// Blocklist List of users or groups denied for the certification
	Blocklist *[]AllowBlockListInputOutput `json:"blocklist,omitempty"`

	// Continuous A flag for a continuous campaign
	Continuous *bool `json:"continuous,omitempty"`

	// CreationDate Creation date of the campaign configuration
	CreationDate *string `json:"creationDate,omitempty"`

	// DefaultReviewer Represents a user group
	DefaultReviewer *UserGroupV1 `json:"defaultReviewer,omitempty"`

	// Description Campaign description
	Description *string `json:"description,omitempty"`

	// Draft A flag for a draft campaign
	Draft *bool `json:"draft,omitempty"`

	// Duration The duration (in milliseconds) for which each campaign instance remains open
	Duration int64 `json:"duration"`

	// EntitlementFilter Rest representation for an entitlement or entitlement condition set filter.
	EntitlementFilter *EntitlementWithConditionSet `json:"entitlementFilter,omitempty"`

	// Frequency A UNIX or Linux Cron-compatible string that defines the start of subsequent instances
	Frequency *string `json:"frequency,omitempty"`

	// ID Campaign configuration ID
	ID *string `json:"id,omitempty"`

	// IsDeleted The campaign configuration was deleted
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// LaunchDate Date when the first instance of the campaign starts
	LaunchDate CampaignConfigurationOutputLaunchDate `json:"launchDate"`

	// MitigationAction The action to be taken after a while to avoid open records when a campaign closes.
	MitigationAction *struct {
		ReminderInterval *int64                                           `json:"reminderInterval,omitempty"`
		Type             *CampaignConfigurationOutputMitigationActionType `json:"type,omitempty"`
	} `json:"mitigationAction,omitempty"`

	// Name Campaign name
	Name string `json:"name"`

	// NextRunDate Estimated next run date for this configuration, if any
	NextRunDate *string `json:"nextRunDate,omitempty"`

	// OverdueAction The action to be taken for open records when a campaign closes.
	OverdueAction *CampaignConfigurationOutputOverdueAction `json:"overdueAction,omitempty"`

	// Owner Represents a user group
	Owner *UserGroupV1 `json:"owner,omitempty"`

	// Preview A flag for a preview campaign, not opened to reviewers
	Preview *bool `json:"preview,omitempty"`

	// Priority Campaign priority
	Priority CampaignConfigurationOutputPriority `json:"priority"`

	// Rev Campaign configuration review
	Rev *string `json:"rev,omitempty"`

	// Reviewer Represents a user group
	Reviewer *UserGroupV1 `json:"reviewer,omitempty"`

	// RunEvery Frequency unit days or months
	RunEvery *struct {
		CronString *string `json:"cronString,omitempty"`
	} `json:"runEvery,omitempty"`

	// RunNow A flag to start the campaign immediately
	RunNow *bool `json:"runNow,omitempty"`

	// SignOff The campaign sign-off policy
	SignOff *CampaignConfigurationOutputSignOff `json:"signOff,omitempty"`

	// Supervisors The list of supervisors identified for the campaign.
	Supervisors *[]UserGroupV1 `json:"supervisors,omitempty"`

	// TenantCreationLimits A JSON object that indicates the limits for this tenant
	TenantCreationLimits *struct {
		// CurrentActiveCampaignAssignments Number of current active campaign assignments
		CurrentActiveCampaignAssignments *int64 `json:"current_active_campaign_assignments,omitempty"`

		// CurrentActiveCampaignInstances Number of current active campaign instances
		CurrentActiveCampaignInstances *int `json:"current_active_campaign_instances,omitempty"`

		// CurrentTotalCampaignAssignmentsInDB Current total campaign assignments in db
		CurrentTotalCampaignAssignmentsInDB *int64 `json:"current_total_campaign_assignments_in_db,omitempty"`

		// MaxActiveCampaignAssignments Maximum number of active campaign assignments
		MaxActiveCampaignAssignments *int64 `json:"max_active_campaign_assignments,omitempty"`

		// MaxActiveCampaignInstances Maximum number of active campaign instances
		MaxActiveCampaignInstances *int `json:"max_active_campaign_instances,omitempty"`

		// MaxTotalCampaignAssignmentsInDB Total campaign assignments in db
		MaxTotalCampaignAssignmentsInDB *int64 `json:"max_total_campaign_assignments_in_db,omitempty"`
	} `json:"tenantCreationLimits,omitempty"`
	TenantID   *string `json:"tenantId,omitempty"`
	TenantUUID *string `json:"tenantUUID,omitempty"`

	// Type Campaign type
	Type      CampaignConfigurationOutputType `json:"type"`
	Whitelist *[]AllowBlockListInputOutput    `json:"whitelist,omitempty"`
}

// CampaignConfigurationOutputLaunchDate Date when the first instance of the campaign starts
type CampaignConfigurationOutputLaunchDate string

// CampaignConfigurationOutputMitigationActionType defines model for CampaignConfigurationOutput.MitigationAction.Type.
type CampaignConfigurationOutputMitigationActionType string

// CampaignConfigurationOutputOverdueAction The action to be taken for open records when a campaign closes.
type CampaignConfigurationOutputOverdueAction string

// CampaignConfigurationOutputPriority Campaign priority
type CampaignConfigurationOutputPriority string

// CampaignConfigurationOutputSignOff The campaign sign-off policy
type CampaignConfigurationOutputSignOff string

// CampaignConfigurationOutputType Campaign type
type CampaignConfigurationOutputType string

// ClassLoader defines model for ClassLoader.
type ClassLoader struct {
	Parent *ClassLoader `json:"parent,omitempty"`
}

// ClientAuthentication defines model for ClientAuthentication.
type ClientAuthentication struct {
	// ClientAssertion The JWT assertion being used to authenticate the client.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType The format of client assertion.
	ClientAssertionType *ClientAuthenticationClientAssertionType `json:"client_assertion_type,omitempty"`

	// ClientID The OIDC client ID that is required when the basic authorization header is not set.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret The OIDC client secret that is required when the basic authorization header is not set and the client is not a public client.
	ClientSecret *string `json:"client_secret,omitempty"`
}

// ClientAuthenticationClientAssertionType The format of client assertion.
type ClientAuthenticationClientAssertionType string

// ConfigDataObject defines model for ConfigDataObject.
type ConfigDataObject struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	EnvID     *string    `json:"envId,omitempty"`
	ID        *string    `json:"id,omitempty"`
	OrgID     *string    `json:"orgId,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Connection defines model for Connection.
type Connection struct {
	AutoCommit           *bool                   `json:"autoCommit,omitempty"`
	Catalog              *string                 `json:"catalog,omitempty"`
	ClientInfo           *map[string]string      `json:"clientInfo,omitempty"`
	Closed               *bool                   `json:"closed,omitempty"`
	Holdability          *int32                  `json:"holdability,omitempty"`
	MetaData             *DatabaseMetaData       `json:"metaData,omitempty"`
	NetworkTimeout       *int32                  `json:"networkTimeout,omitempty"`
	ReadOnly             *bool                   `json:"readOnly,omitempty"`
	Schema               *string                 `json:"schema,omitempty"`
	TransactionIsolation *int32                  `json:"transactionIsolation,omitempty"`
	TypeMap              *map[string]interface{} `json:"typeMap,omitempty"`
	Warnings             *SQLWarning             `json:"warnings,omitempty"`
}

// Constraints defines model for Constraints.
type Constraints struct {
	Mandatory             *bool            `json:"mandatory,omitempty"`
	ReadAccessForEndUser  *bool            `json:"readAccessForEndUser,omitempty"`
	Unique                *bool            `json:"unique,omitempty"`
	ValueConstraint       *ValueConstraint `json:"valueConstraint,omitempty"`
	ValueConstraintFormat *string          `json:"valueConstraintFormat,omitempty"`
	ValueConstraintType   *string          `json:"valueConstraintType,omitempty"`
	WriteAccessForEndUser *bool            `json:"writeAccessForEndUser,omitempty"`
}

// CreateConflict defines model for CreateConflict.
type CreateConflict struct {
	// MessageDescription A requester locale-specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// CustomAttribute defines model for CustomAttribute.
type CustomAttribute struct {
	// Name The SCIM name of the custom attribute.  The SCIM name for a custom schema attribute is defined for the tenant by using the POST /Schema/attributes API.
	Name string `json:"name"`

	// Values The values of the custom attribute. Maximum length is 1000 characters.
	Values []string `json:"values"`
}

// DatabaseMetaData defines model for DatabaseMetaData.
type DatabaseMetaData struct {
	CatalogAtStart              *bool                          `json:"catalogAtStart,omitempty"`
	CatalogSeparator            *string                        `json:"catalogSeparator,omitempty"`
	CatalogTerm                 *string                        `json:"catalogTerm,omitempty"`
	Catalogs                    *ResultSet                     `json:"catalogs,omitempty"`
	ClientInfoProperties        *ResultSet                     `json:"clientInfoProperties,omitempty"`
	Connection                  *Connection                    `json:"connection,omitempty"`
	DatabaseMajorVersion        *int32                         `json:"databaseMajorVersion,omitempty"`
	DatabaseMinorVersion        *int32                         `json:"databaseMinorVersion,omitempty"`
	DatabaseProductName         *string                        `json:"databaseProductName,omitempty"`
	DatabaseProductVersion      *string                        `json:"databaseProductVersion,omitempty"`
	DefaultTransactionIsolation *int32                         `json:"defaultTransactionIsolation,omitempty"`
	DriverMajorVersion          *int32                         `json:"driverMajorVersion,omitempty"`
	DriverMinorVersion          *int32                         `json:"driverMinorVersion,omitempty"`
	DriverName                  *string                        `json:"driverName,omitempty"`
	DriverVersion               *string                        `json:"driverVersion,omitempty"`
	ExtraNameCharacters         *string                        `json:"extraNameCharacters,omitempty"`
	IdentifierQuoteString       *string                        `json:"identifierQuoteString,omitempty"`
	JdbcmajorVersion            *int32                         `json:"jdbcmajorVersion,omitempty"`
	JdbcminorVersion            *int32                         `json:"jdbcminorVersion,omitempty"`
	MaxBinaryLiteralLength      *int32                         `json:"maxBinaryLiteralLength,omitempty"`
	MaxCatalogNameLength        *int32                         `json:"maxCatalogNameLength,omitempty"`
	MaxCharLiteralLength        *int32                         `json:"maxCharLiteralLength,omitempty"`
	MaxColumnNameLength         *int32                         `json:"maxColumnNameLength,omitempty"`
	MaxColumnsInGroupBy         *int32                         `json:"maxColumnsInGroupBy,omitempty"`
	MaxColumnsInIndex           *int32                         `json:"maxColumnsInIndex,omitempty"`
	MaxColumnsInOrderBy         *int32                         `json:"maxColumnsInOrderBy,omitempty"`
	MaxColumnsInSelect          *int32                         `json:"maxColumnsInSelect,omitempty"`
	MaxColumnsInTable           *int32                         `json:"maxColumnsInTable,omitempty"`
	MaxConnections              *int32                         `json:"maxConnections,omitempty"`
	MaxCursorNameLength         *int32                         `json:"maxCursorNameLength,omitempty"`
	MaxIndexLength              *int32                         `json:"maxIndexLength,omitempty"`
	MaxLogicalLobSize           *int64                         `json:"maxLogicalLobSize,omitempty"`
	MaxProcedureNameLength      *int32                         `json:"maxProcedureNameLength,omitempty"`
	MaxRowSize                  *int32                         `json:"maxRowSize,omitempty"`
	MaxSchemaNameLength         *int32                         `json:"maxSchemaNameLength,omitempty"`
	MaxStatementLength          *int32                         `json:"maxStatementLength,omitempty"`
	MaxStatements               *int32                         `json:"maxStatements,omitempty"`
	MaxTableNameLength          *int32                         `json:"maxTableNameLength,omitempty"`
	MaxTablesInSelect           *int32                         `json:"maxTablesInSelect,omitempty"`
	MaxUserNameLength           *int32                         `json:"maxUserNameLength,omitempty"`
	NumericFunctions            *string                        `json:"numericFunctions,omitempty"`
	ProcedureTerm               *string                        `json:"procedureTerm,omitempty"`
	ReadOnly                    *bool                          `json:"readOnly,omitempty"`
	ResultSetHoldability        *int32                         `json:"resultSetHoldability,omitempty"`
	RowIDLifetime               *DatabaseMetaDataRowIDLifetime `json:"rowIdLifetime,omitempty"`
	SchemaTerm                  *string                        `json:"schemaTerm,omitempty"`
	Schemas                     *ResultSet                     `json:"schemas,omitempty"`
	SearchStringEscape          *string                        `json:"searchStringEscape,omitempty"`
	Sqlkeywords                 *string                        `json:"sqlkeywords,omitempty"`
	SqlstateType                *int32                         `json:"sqlstateType,omitempty"`
	StringFunctions             *string                        `json:"stringFunctions,omitempty"`
	SystemFunctions             *string                        `json:"systemFunctions,omitempty"`
	TableTypes                  *ResultSet                     `json:"tableTypes,omitempty"`
	TimeDateFunctions           *string                        `json:"timeDateFunctions,omitempty"`
	TypeInfo                    *ResultSet                     `json:"typeInfo,omitempty"`
	URL                         *string                        `json:"url,omitempty"`
	UserName                    *string                        `json:"userName,omitempty"`
}

// DatabaseMetaDataRowIDLifetime defines model for DatabaseMetaData.RowIDLifetime.
type DatabaseMetaDataRowIDLifetime string

// DeleteConflict defines model for DeleteConflict.
type DeleteConflict struct {
	// MessageDescription A requester locale-specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// DeploymentVisibility defines model for DeploymentVisibility.
type DeploymentVisibility struct {
	Subscribe Subscribe `json:"subscribe"`
	View      View      `json:"view"`
}

// Duration defines model for Duration.
type Duration struct {
	Nano     *int32          `json:"nano,omitempty"`
	Negative *bool           `json:"negative,omitempty"`
	Seconds  *int64          `json:"seconds,omitempty"`
	Units    *[]TemporalUnit `json:"units,omitempty"`
	Zero     *bool           `json:"zero,omitempty"`
}

// EmailAddress defines model for EmailAddress.
type EmailAddress struct {
	// Type A label that indicates the attribute function; for example, "work".  Only a single email is allowed.
	Type EmailAddressType `json:"type"`

	// Value The e-mail addresses for the user. The value is canonicalized by the service provider. For example, bjensen@example.com instead of bjensen@EXAMPLE.COM. Must be RFC 2822 compliant. Maximum length is 128 characters.
	Value string `json:"value"`
}

// EmailAddressType A label that indicates the attribute function; for example, "work".  Only a single email is allowed.
type EmailAddressType string

// EnterpriseUser defines model for EnterpriseUser.
type EnterpriseUser struct {
	// Department Identifies the name of the department. Maximum length is 128 characters.
	Department *string `json:"department,omitempty"`

	// EmployeeNumber A string identifier, typically numeric or alphanumeric, that is assigned to a person. Typically the number is based on the order of hire. Maximum length is 128 characters.
	EmployeeNumber *string  `json:"employeeNumber,omitempty"`
	Manager        *Manager `json:"manager,omitempty"`
}

// EntitlementWithConditionSet Rest representation for an entitlement or entitlement condition set filter.
type EntitlementWithConditionSet struct {
	// EntitlementExclusionList List of Entitlements to be excluded
	EntitlementExclusionList *[]Entitlement0 `json:"entitlementExclusionList,omitempty"`

	// EntitlementInclusionList List of Entitlements to be included
	EntitlementInclusionList *[]Entitlement0 `json:"entitlementInclusionList,omitempty"`
}

// Entitlement0 Rest representation for an entitlement.
type Entitlement0 struct {
	// EntitlementID Unique id of an entitlement
	EntitlementID string `json:"entitlementId"`
}

// EnumerationLocale defines model for EnumerationLocale.
type EnumerationLocale = map[string]interface{}

// EnumerationServlet defines model for EnumerationServlet.
type EnumerationServlet = map[string]interface{}

// EnumerationString defines model for EnumerationString.
type EnumerationString = map[string]interface{}

// ErrorBean defines model for ErrorBean.
type ErrorBean struct {
	// MessageDescription The Locale specific descriptive message
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier
	MessageID string `json:"messageId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// MessageDescription Requester locale specific descriptive message.
	MessageDescription *string `json:"messageDescription,omitempty"`

	// MessageID The message key identifier.
	MessageID *string `json:"messageId,omitempty"`
}

// Error0 defines model for Error_0.
type Error0 struct {
	// Error The OIDC error.
	Error string `json:"error"`

	// ErrorDescription The OIDC error description.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// ExternalErrorMessage1 defines model for ExternalErrorMessage1.
type ExternalErrorMessage1 struct {
	// Detail A detailed human-readable message.
	Detail *string `json:"detail,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure.  The schema "urn:ietf:params:scim:api:messages:2.0:Error" is the URI as required by the SCIM specification.
	Schemas []string `json:"schemas"`

	// Status The HTTP status code expressed as a JSON string.
	Status string `json:"status"`
}

// FederationPartnerV2 defines model for Federation_Partner_V2.
type FederationPartnerV2 struct {
	Configuration *FederationPartnerV2 `json:"configuration,omitempty"`
	Enabled       *bool                `json:"enabled,omitempty"`
	ID            *string              `json:"id,omitempty"`
	Name          *string              `json:"name,omitempty"`
	Role          *string              `json:"role,omitempty"`
	TemplateName  *string              `json:"templateName,omitempty"`
}

// FilterRegistration defines model for FilterRegistration.
type FilterRegistration struct {
	ClassName           *string            `json:"className,omitempty"`
	InitParameters      *map[string]string `json:"initParameters,omitempty"`
	Name                *string            `json:"name,omitempty"`
	ServletNameMappings *[]string          `json:"servletNameMappings,omitempty"`
	URLPatternMappings  *[]string          `json:"urlPatternMappings,omitempty"`
}

// Forbidden0 defines model for Forbidden_0.
type Forbidden0 struct {
	// MessageDescription A requester locale-specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// Forbidden3 The message response to the given request
type Forbidden3 struct {
	// MessageDescription Requester locale specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// Function defines model for Function.
type Function struct {
	// Custom The custom function
	Custom *string `json:"custom,omitempty"`

	// Name The function name
	Name *string `json:"name,omitempty"`
}

// GetGroupsResponseV2 defines model for GetGroupsResponseV2.
type GetGroupsResponseV2 struct {
	// Resources A list of groups.
	Resources *[]GroupResponseV2 `json:"Resources,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schema "urn:ietf:params:scim:api:messages:2.0:ListResponse" is returned in the response.
	Schemas []string `json:"schemas"`

	// TotalResults The total number of groups that were found that match the specified search criteria for the specified tenant.
	TotalResults int32 `json:"totalResults"`
}

// GetUsersResponseV2 defines model for GetUsersResponseV2.
type GetUsersResponseV2 struct {
	// Resources A list of users.
	Resources *[]GetUsersUserResponseV2 `json:"Resources,omitempty"`

	// ItemsPerPage The number of resources that are returned in a list response page.
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schema "urn:ietf:params:scim:api:messages:2.0:ListResponse" is returned in the response.
	Schemas []string `json:"schemas"`

	// StartIndex The 1-based index of the first result in the current set of list results.
	StartIndex *int32 `json:"startIndex,omitempty"`

	// TotalResults The total number of users that were found that match the specified search criteria for the specified tenant. An upper limit is imposed on this value, in that the total number of users that match the search criteria may be larger than this value.  A limit of 2500 users matching the search criteria will be returned.
	TotalResults int32 `json:"totalResults"`
}

// GetUsersUserResponseV2 defines model for GetUsersUserResponseV2.
type GetUsersUserResponseV2 struct {
	// Active A Boolean value that indicates the user's administrative status. The definitive meaning of this attribute is determined by the service provider. For example, a value of true indicates that the user can, log in, while a value of false indicates that the user's account has been suspended. If not specified, the value defaults to true.
	Active *bool `json:"active,omitempty"`

	// Addresses A list of addresses that are associated with the user.
	Addresses []Address `json:"addresses"`

	// DisplayName The name of the user that is displayed to users. Each user returned may include a non-empty displayName value. Typically it is the full name of the user being described, for example, Babs Jensen or Ms. Barbara J Jensen. However, if that information is unavailable, a username or handle can be used, for example, bjensen. The value is the primary textual label by which this user is normally displayed by the service provider when presenting information to users.
	DisplayName *string `json:"displayName,omitempty"`

	// Emails A list of email addresses that are associated with the user. Only one is supported.
	Emails []EmailAddress `json:"emails"`

	// ExternalID A unique identifier for the resource that is defined by the provisioning client. It identifies a resource between the provisioning client and the service provider. The client can use a filter to locate the resource with an identifier from the provisioning domain.
	ExternalID *string `json:"externalId,omitempty"`

	// ID The unique identifier for the resource as defined by the service. This attribute is read-only and ise sent by the service. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored.
	ID   string  `json:"id"`
	Meta *MetaV2 `json:"meta,omitempty"`
	Name Name    `json:"name"`

	// PhoneNumbers A list of phone numbers that are associated with the user.
	PhoneNumbers *[]PhoneNumber `json:"phoneNumbers,omitempty"`

	// PreferredLanguage The language code identifying the preferred language of this identity, for example, en-us or fr-ca.
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schemas "urn:ietf:params:scim:schemas:core:2.0:User", "urn:ietf:params:scim:schemas:extension:ibm:2.0:User" and "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User" are returned in the response.
	Schemas []string `json:"schemas"`

	// Title The user's title, such as "Vice President."
	Title                                             *string                `json:"title,omitempty"`
	UrnIetfParamsScimSchemasExtensionEnterprise20User *EnterpriseUser        `json:"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20User        *CICCustomUserResponse `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:User,omitempty"`

	// UserName The unique identifier for the user that is typically used by the user to directly authenticate to the service provider. It is often displayed to the user as their unique identifier within the system (as opposed to the id or externalId attributes, which are generally opaque and not user-friendly identifiers). Each user must include a non-empty userName value. This identifier must be unique across the service consumer's entire set of users. It must be a stable ID that does not change when the same user is returned in subsequent requests.
	UserName string `json:"userName"`
}

// GroupMembers defines model for GroupMembers.
type GroupMembers struct {
	// Type The type of group member that is being added.
	Type GroupMembersType `json:"type"`

	// Value The unique identifier of the member that is being added to the group.
	Value string `json:"value"`
}

// GroupMembersType The type of group member that is being added.
type GroupMembersType string

// GroupMembersResponse defines model for GroupMembersResponse.
type GroupMembersResponse struct {
	// Ref A sub-attr required by the SCIM specification the contains the URI of the SCIM resource.
	Ref string `json:"$ref"`

	// Active Valid for user type members only. A Boolean value that indicates the user's administrative status. The definitive meaning of this attribute is determined by the service provider. For example, a value of true indicates that the user is, for example, able to log in, while a value of false indicates that the user's account has been suspended. If not specified, the value defaults to true.
	Active *bool `json:"active,omitempty"`

	// Addresses Valid for user type members only. A list of addresses that are associated with the user.
	Addresses []Address `json:"addresses"`

	// DisplayName The name of the user or group that is displayed to users. Each member returned may include a non-empty displayName value. For a user type member, typically it is the full name of the user that is being described, for example, Babs Jensen or Ms. Barbara J Jensen. However, if that information is unavailable, a username or handle can be used, for example, bjensen. The value is the primary textual label by which this user is normally displayed by the service provider when presenting information to users.
	DisplayName *string `json:"displayName,omitempty"`

	// Emails Valid for user type members only. A list of email addresses that are associated with the user.
	Emails []EmailAddress `json:"emails"`

	// ExternalID Valid for user type members only. A unique identifier for the resource that is defined by the provisioning client. It identifies a resource between the provisioning client and the service provider. The client can use a filter to locate the resource with the identifier from the provisioning domain.
	ExternalID *string `json:"externalId,omitempty"`

	// ID The unique identifier for the resource as defined by the service. This attribute is read-only and is sent by the service. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored.
	ID   *string `json:"id,omitempty"`
	Name Name    `json:"name"`

	// PhoneNumbers Valid for user type members only. A list of phone numbers that are associated with the user.
	PhoneNumbers *[]PhoneNumber `json:"phoneNumbers,omitempty"`

	// PreferredLanguage Valid for user type members only. The language code identifying the preferred language of this identity, for example, en-us or fr-ca.
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`

	// Title Valid for user type members only. The user's title, such as "Vice President".
	Title *string `json:"title,omitempty"`

	// Type The type of group member.
	Type                                              GroupMembersResponseType `json:"type"`
	UrnIetfParamsScimSchemasExtensionEnterprise20User *EnterpriseUser          `json:"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20User        *CICCustomUserResponse   `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:User,omitempty"`

	// UserName Valid for user type members only. The unique identifier for the user that is typically used by the user to directly authenticate to the service provider. It is often displayed to the user as their unique identifier within the system (as opposed to the id or externalId attributes, which are generally opaque and not user-friendly identifiers). Each user must include a non-empty userName value. This identifier must be unique across the service consumer's entire set of users. It must be a stable ID that does not change when the same user is returned in subsequent requests.
	UserName string `json:"userName"`

	// Value A sub-attr required by the SCIM specification that contains the "id" of the SCIM resource.
	Value string `json:"value"`
}

// GroupMembersResponseType The type of group member.
type GroupMembersResponseType string

// GroupOwner defines model for GroupOwner.
type GroupOwner struct {
	// Ref The URI of the SCIM resource representing the user.  This value is readonly.
	Ref *string `json:"$ref,omitempty"`

	// DisplayName The display name of the user. This value is readonly.
	DisplayName *string `json:"displayName,omitempty"`

	// Value The id of the group owner
	Value string `json:"value"`
}

// GroupResponseV2 defines model for GroupResponseV2.
type GroupResponseV2 struct {
	// Bookmark An opaque string that is used by the system to get the next 2500 members of this group.  The existence of this element in the GET /v2.0/Groups/{id} response payload indicates that more members exist that were not returned in the call.  To get the next set of members, the caller makes an additional call to the same endpoint, and passes the bookmark value as a query parameter named "nextPage". For example ?nextPage=XASDGAJDGKAWHGI=.  The caller can continue to make calls to the endpoint until no bookmark element are returned in the response payload, which indicates that all group members were returned.  A bookmark is generated from a membershipType query.  The bookmark feature is available for tenants that have large group support enabled.
	Bookmark *string `json:"bookmark,omitempty"`

	// DisplayName A human-readable name for the group.
	DisplayName string `json:"displayName"`

	// ExternalID Identifier of the Group resource as defined by the provisioning client.
	ExternalID *string `json:"externalId,omitempty"`

	// ID The unique identifier for the resource as defined by the service. This attribute is read-only and will be sent by the service. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored.
	ID *string `json:"id,omitempty"`

	// Members A list of members that belong to this group.  If the group has more than 10,000 members, then this array is empty, unless large group support is enabled for the tenant.  With large group support enabled, each call to the GET /v2.0/Groups/{id} endpoint returns at most 2,500 members of the group.  If more members of the group exist that were not returned, a bookmark is returned in the response.  The bookmark is used to get the next set of group members.  See the "bookmark" property for more details.
	Members *[]GroupMembersResponse `json:"members,omitempty"`
	Meta    *MetaV2                 `json:"meta,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schemas "urn:ietf:params:scim:schemas:core:2.0:Group"   and "urn:ietf:params:scim:schemas:extension:ibm:2.0:Group" are returned in the response.
	Schemas                                     []string                `json:"schemas"`
	UrnIetfParamsScimSchemasExtensionIbm20Group *CICCustomGroupResponse `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:Group,omitempty"`
}

// GroupV2 defines model for GroupV2.
type GroupV2 struct {
	// DisplayName The display name of the group. Maximum length is 255 characters.
	DisplayName string `json:"displayName"`

	// ExternalID Identifier of the Group resource as defined by the provisioning client. Maximum length is 240 characters.
	ExternalID *string `json:"externalId,omitempty"`

	// Members A list of members that are being added.  When creating a group, the number of elements must be less than or equal to 10,000.
	Members *[]GroupMembers `json:"members,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure.   The schemas "urn:ietf:params:scim:schemas:core:2.0:Group", urn:ietf:params:scim:schemas:extension:ibm:2.0:Group",  and "urn:ietf:params:scim:schemas:extension:ibm:2.0:Notification" are valid.  The core group schema is required.
	Schemas                                            []string        `json:"schemas"`
	UrnIetfParamsScimSchemasExtensionIbm20Group        *CICCustomGroup `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:Group,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20Notification *Notifications  `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:Notification,omitempty"`
	Visible                                            *bool           `json:"visible,omitempty"`
}

// Groups defines model for Groups.
type Groups struct {
	// Ref A sub-attr required by the SCIM specification the contains the URI of the SCIM resource the user belongs to.
	Ref string `json:"$ref"`

	// DisplayName The display name of the group that the user belongs to.
	DisplayName *string `json:"displayName,omitempty"`

	// ID The identifier of the group that the user belongs to.
	ID *string `json:"id,omitempty"`

	// Value A sub-attr required by the SCIM specification that contains the "id" of the SCIM resource the user belongs to.
	Value string `json:"value"`
}

// Header The keys should be in canonical form, as returned by
// CanonicalHeaderKey.
type Header struct {
	Key                  *string             `json:"key,omitempty"`
	Value                *string             `json:"value,omitempty"`
	AdditionalProperties map[string][]string `json:"-"`
}

// IdentitySourceInstancesData defines model for IdentitySourceInstancesData.
type IdentitySourceInstancesData struct {
	// AttributeMappings A set of attribute mappings that are associated with the identity source instance.
	//  It is an array of attribute mappings that are not required but an optional input for certain runtime login flows.
	//  The properties and the number of properties differe with the provider type.
	AttributeMappings *[]AttributeMapping `json:"attributeMappings,omitempty"`

	// Enabled A Boolean flag that indicates whether this instance is enabled or disabled. Only enabled identity source instances are displayed on the login selection page.
	Enabled bool `json:"enabled"`

	// InstanceName The instance name to be displayed on login selection page.
	InstanceName string `json:"instanceName"`

	// Predefined This property is currently not in use. We do not support plugging-in any other custom types of identity providers.
	//  However, the purpose was to indicate that this instance is special; it neither be created and nor deleted.
	Predefined *bool `json:"predefined,omitempty"`

	// Properties A set of properties that are associated with the identity source instance.
	//   It is an array of properties of identity source instance that are required to perform the runtime login flow.
	//   The properties and the number of properties differ with the provider type.
	Properties []IdentitySourceInstancesPropertiesData `json:"properties"`

	// SourceTypeID The numeric identifier of identity provider type.
	SourceTypeID int32 `json:"sourceTypeId"`

	// Status A string label that indicates whether this instance is configured. If specified, this property is ignored during creation.
	Status *IdentitySourceInstancesDataStatus `json:"status,omitempty"`
}

// IdentitySourceInstancesDataStatus A string label that indicates whether this instance is configured. If specified, this property is ignored during creation.
type IdentitySourceInstancesDataStatus string

// IdentitySourceInstancesPropertiesData defines model for IdentitySourceInstancesPropertiesData.
type IdentitySourceInstancesPropertiesData struct {
	// Key Property key.
	Key string `json:"key"`

	// Sensitive Indicates whether this property holds any secrets that should not be disclosed.<br> If the property is sensitive, then the property value will be masked out with asterisk characters.
	Sensitive bool `json:"sensitive"`

	// Value Property value. Secret values will be masked out with asterisk characters.
	Value string `json:"value"`
}

// IdentitySourceIntancesDataList defines model for IdentitySourceIntancesDataList.
type IdentitySourceIntancesDataList struct {
	// IdentitySources A list of identity source intances configured for the tenant.
	IdentitySources []IdentitySourceInstancesData `json:"identitySources"`

	// Total Total number of identity source intances configured for the tenant.
	Total int32 `json:"total"`
}

// JSONArray defines model for JsonArray.
type JSONArray struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	Empty           *bool          `json:"empty,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONNull defines model for JsonNull.
type JSONNull struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONObject defines model for JsonObject.
type JSONObject struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONPrimitive defines model for JsonPrimitive.
type JSONPrimitive struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	Boolean         *bool          `json:"boolean,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
	Number          *bool          `json:"number,omitempty"`
	String          *bool          `json:"string,omitempty"`
}

// JspConfigDescriptor defines model for JspConfigDescriptor.
type JspConfigDescriptor struct {
	JspPropertyGroups *[]JspPropertyGroupDescriptor `json:"jspPropertyGroups,omitempty"`
	Taglibs           *[]TaglibDescriptor           `json:"taglibs,omitempty"`
}

// JspPropertyGroupDescriptor defines model for JspPropertyGroupDescriptor.
type JspPropertyGroupDescriptor struct {
	Buffer                         *string   `json:"buffer,omitempty"`
	DefaultContentType             *string   `json:"defaultContentType,omitempty"`
	DeferredSyntaxAllowedAsLiteral *string   `json:"deferredSyntaxAllowedAsLiteral,omitempty"`
	ElIgnored                      *string   `json:"elIgnored,omitempty"`
	ErrorOnUndeclaredNamespace     *string   `json:"errorOnUndeclaredNamespace,omitempty"`
	IncludeCodas                   *[]string `json:"includeCodas,omitempty"`
	IncludePreludes                *[]string `json:"includePreludes,omitempty"`
	IsXML                          *string   `json:"isXml,omitempty"`
	PageEncoding                   *string   `json:"pageEncoding,omitempty"`
	ScriptingInvalid               *string   `json:"scriptingInvalid,omitempty"`
	TrimDirectiveWhitespaces       *string   `json:"trimDirectiveWhitespaces,omitempty"`
	URLPatterns                    *[]string `json:"urlPatterns,omitempty"`
}

// LargeGroupResponse defines model for LargeGroupResponse.
type LargeGroupResponse struct {
	// DisplayName A human-readable name for the group.
	DisplayName string `json:"displayName"`

	// ExternalID Identifier of the Group resource as defined by the provisioning client.
	ExternalID *string `json:"externalId,omitempty"`

	// ID The unique identifier for the resource as defined by the service. This attribute is read-only and will be sent by the service. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored.
	ID   *string `json:"id,omitempty"`
	Meta *MetaV2 `json:"meta,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schemas "urn:ietf:params:scim:schemas:core:2.0:Group"   and "urn:ietf:params:scim:schemas:extension:ibm:2.0:Group" are returned in the response.
	Schemas                                     []string                     `json:"schemas"`
	UrnIetfParamsScimSchemasExtensionIbm20Group *CICCustomLargeGroupResponse `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:Group,omitempty"`
}

// LastMFA defines model for LastMFA.
type LastMFA struct {
	// Type The type of MFA
	Type string `json:"type"`

	// Value The value for this type of MFA
	Value string `json:"value"`
}

// LinkedAccount defines model for LinkedAccount.
type LinkedAccount struct {
	// ExternalID The ID of a user's external account The maximum length, in combination with realm, is 239 characters.
	ExternalID string `json:"externalId"`

	// Realm The realm name of the user's external account The maximum length, in combination with externalId, is 239 characters.
	Realm string `json:"realm"`
}

// Locale defines model for Locale.
type Locale struct {
	Country                 *string   `json:"country,omitempty"`
	DisplayCountry          *string   `json:"displayCountry,omitempty"`
	DisplayLanguage         *string   `json:"displayLanguage,omitempty"`
	DisplayName             *string   `json:"displayName,omitempty"`
	DisplayScript           *string   `json:"displayScript,omitempty"`
	DisplayVariant          *string   `json:"displayVariant,omitempty"`
	ExtensionKeys           *[]string `json:"extensionKeys,omitempty"`
	Iso3Country             *string   `json:"iso3Country,omitempty"`
	Iso3Language            *string   `json:"iso3Language,omitempty"`
	Language                *string   `json:"language,omitempty"`
	Script                  *string   `json:"script,omitempty"`
	UnicodeLocaleAttributes *[]string `json:"unicodeLocaleAttributes,omitempty"`
	UnicodeLocaleKeys       *[]string `json:"unicodeLocaleKeys,omitempty"`
	Variant                 *string   `json:"variant,omitempty"`
}

// Manager defines model for Manager.
type Manager struct {
	// Ref The URI of the SCIM resource representing the user's manager.  This value is readonly.
	Ref *string `json:"$ref,omitempty"`

	// DisplayName The display name of the user's manager. This value is readonly.
	DisplayName *string `json:"displayName,omitempty"`

	// Value The "id" of the SCIM resource representing the user's manager.
	Value *string `json:"value,omitempty"`
}

// MetaV2 defines model for MetaV2.
type MetaV2 struct {
	// Created A DateTime string that indicates when the resource was created.
	Created *string `json:"created,omitempty"`

	// Deactivated A readonly string that indicates why the account is deactivated.  Valid values are "api", "timestamp", and "cleanup".  The value "api" means that the user was deactivated by using an API.  The value "timestamp" means that the user was deactivated by the system because the account expired.  The value "cleanup" means that the user was deactivated by the system during account cleanup processing.
	Deactivated *MetaV2Deactivated `json:"deactivated,omitempty"`

	// LastModified A DateTime string that indicates when the resource was last modified.
	LastModified *string `json:"lastModified,omitempty"`

	// Location The URI of the resource that is being returned.
	Location *string `json:"location,omitempty"`

	// ResourceType The field that indicates the type of resource.
	ResourceType *string `json:"resourceType,omitempty"`
}

// MetaV2Deactivated A readonly string that indicates why the account is deactivated.  Valid values are "api", "timestamp", and "cleanup".  The value "api" means that the user was deactivated by using an API.  The value "timestamp" means that the user was deactivated by the system because the account expired.  The value "cleanup" means that the user was deactivated by the system during account cleanup processing.
type MetaV2Deactivated string

// Metadata0 Metadata for a access policy
type Metadata0 struct {
	// EnforcementType The enforcement type of the policy
	EnforcementType *Metadata0EnforcementType `json:"enforcementType,omitempty"`

	// EvaluationContext Sub-policy evaluation details
	EvaluationContext *map[string]string `json:"evaluationContext,omitempty"`

	// Label A label for the revision
	Label *string `json:"label,omitempty"`

	// Schema The schema version of this policy
	Schema *string `json:"schema,omitempty"`

	// Scope Which scopes are permitted to apply this policy
	Scope *[]Metadata0Scope `json:"scope,omitempty"`

	// State The state of the revision
	State Metadata0State `json:"state"`

	// TenantDefaultPolicy should this policy be the default
	TenantDefaultPolicy *bool `json:"tenantDefaultPolicy,omitempty"`
}

// Metadata0EnforcementType The enforcement type of the policy
type Metadata0EnforcementType string

// Metadata0Scope defines model for Metadata0.Scope.
type Metadata0Scope string

// Metadata0State The state of the revision
type Metadata0State string

// Name defines model for Name.
type Name struct {
	// FamilyName The family name of the user, or the last name in most Western languages. For example, Jensen is the family name from the full name Ms. Barbara J Jensen, PhD. Maximum length is 80 characters.
	FamilyName *string `json:"familyName,omitempty"`

	// Formatted The full name of the user that includes all  user names, middle names, and suffixes, that are formatted for display. This value is returned by the service provider if it is not part of the POST or PUT payloads. If the POST or PUT JSON payload contains the value for this attribute, the value in the payload takes precedence. Maximum length is 240 characters.
	Formatted *string `json:"formatted,omitempty"`

	// GivenName The given name of the user, or first name in most Western languages. For example, Barbara is the given name from the full name Ms. Barbara J Jensen, PhD. Maximum length is 80 characters.
	GivenName *string `json:"givenName,omitempty"`

	// MiddleName The middle name(s) of the user. Maximum length is 80 characters.
	MiddleName *string `json:"middleName,omitempty"`
}

// NotFound0 defines model for NotFound_0.
type NotFound0 struct {
	// MessageDescription A requester locale-specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// NotFound2 The message response to the given request
type NotFound2 struct {
	// MessageDescription Requester locale specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// Notifications defines model for Notifications.
type Notifications struct {
	// NotifyManager Indicates whether the notification should be sent to the user's manager (if one is set) when a user's password is set or modified. If the attribute is not provided, the behavior defaults to false. This attribute does not apply if the notifyType attribute is set to NONE.
	NotifyManager *bool `json:"notifyManager,omitempty"`

	// NotifyPassword Indicates whether the user's password is included in the notification that is sent  to the user. If the attribute is not provided, the behavior defaults to true. This attribute does not apply if the notifyType attribute is set to NONE.
	NotifyPassword *bool `json:"notifyPassword,omitempty"`

	// NotifyType The value that indicates the type of notification that is sent to the user. If not provided, the default value is EMAIL.
	NotifyType *NotificationsNotifyType `json:"notifyType,omitempty"`
}

// NotificationsNotifyType The value that indicates the type of notification that is sent to the user. If not provided, the default value is EMAIL.
type NotificationsNotifyType string

// Number defines model for Number.
type Number = map[string]interface{}

// OperationStatusSummary defines model for OperationStatusSummary.
type OperationStatusSummary struct {
	Errors   *[]string            `json:"errors,omitempty"`
	Messages *map[string][]string `json:"messages,omitempty"`
}

// PaginatedAttribute0 defines model for PaginatedAttribute_0.
type PaginatedAttribute0 struct {
	// Attributes list of attributes
	Attributes []Attribute0 `json:"attributes"`
	Count      int          `json:"count"`
	Limit      int          `json:"limit"`
	Page       int          `json:"page"`
	Total      int          `json:"total"`
}

// PatchBody defines model for PatchBody.
type PatchBody struct {
	// Operations An array of operation objects to be performed.  Operation objects must have exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", or "replace". Values are errors.
	Operations []PatchOperation0 `json:"Operations"`

	// Schemas The body of each SCIM PATCH request must contain the "schemas" attribute with the URI value: "urn:ietf:params:scim:api:messages:2.0:PatchOp".
	Schemas []string `json:"schemas"`
}

// PatchOperation defines model for PatchOperation.
type PatchOperation struct {
	// Op The patch operation to be executed
	Op PatchOperationOp `json:"op"`

	// Path The attribute id for the patch operation
	Path string `json:"path"`

	// Value The values to update for the resource.<br><br>For global attributes, the following values can be updated using the PATCH API: tags, value, credNameOverrides, function. <br><br>For custom attributes, the following values can be updated using the PATCH API: name, description, sourceType, datatype, tags, value, credName, credNameOverrides, function
	Value *map[string]interface{} `json:"value,omitempty"`
}

// PatchOperationOp The patch operation to be executed
type PatchOperationOp string

// PatchOperationResponse defines model for PatchOperationResponse.
type PatchOperationResponse struct {
	// MessageDescription The error message describing the overall status of the patch operation
	MessageDescription string `json:"messageDescription"`

	// MessageID The error ID describing the overall status of the patch operation
	MessageID string `json:"messageId"`

	// Results The list of execution results for the patch operations requested
	Results []PatchOperationResult `json:"results"`
}

// PatchOperationResult defines model for PatchOperationResult.
type PatchOperationResult struct {
	// Error The error message describing any failures or errors that occurred
	Error *string `json:"error,omitempty"`

	// ErrorID The error ID describing any failures or errors that occurred
	ErrorID *string `json:"errorID,omitempty"`

	// Op The patch operation to be executed
	Op PatchOperationResultOp `json:"op"`

	// Path The attribute id for the patch operation
	Path string `json:"path"`

	// Result The result of the operation
	Result PatchOperationResultResult `json:"result"`

	// Value The values to update for the resource
	Value *string `json:"value,omitempty"`
}

// PatchOperationResultOp The patch operation to be executed
type PatchOperationResultOp string

// PatchOperationResultResult The result of the operation
type PatchOperationResultResult string

// PatchOperation0 defines model for PatchOperation_0.
type PatchOperation0 struct {
	// Op The operation to be performed.
	Op PatchOperation0Op `json:"op"`

	// Path The string that contains an attribute path that describes the target of the operation.The "path" attribute is required for all operations.Examples of valid "path" specification formats include: <br> <br>     "path":"title" <br>     "path":"name.formatted" <br>     "path":"phoneNumbers[type eq \"work\"]" <br>     "path":"emails[type eq \"work\"].value" <br> <br>As shown, "section filters" (ex: [type eq \"work\"]) can be used to allow selection of specific values of multi-valued attributes. The supported filter operators include: <br> <br>     eq: The attribute and operation values must be identical for a match. <br>     ne: Matches if the attribute and operation values are not identical. <br>     co: The entire operation value must be a substring of the attribute value. <br>     sw: The entire operation value must be a substring of the attribute value, matching from the beginning. <br>     ew: The entire operation value must be a substring of the attribute value, matching from the end. <br>     pr: If the attribute value is present, there is a match. <br>     gt: If the attribute value is greater than the operation value, there is a match. <br>     ge: If the attribute value is greater than or equal to the operation value, there is a match. <br>     lt: If the attribute value is less than the operator value, there is a match. <br>     le: If the attribute value is less than or equal to the operator value, there is a match. <br>Only a single, simple filter can be specified.
	Path string `json:"path"`

	// Value The attribute content used for the operation. The "value" attribute is required for the "add" and "replace" operations. The "value" attribute is allowed with "remove" operations only when the "path" identifies  a single object (specified by a selection filter), and the attribute path identifies an array attribute.  Currently, this usage is for removing values from a custom attribute's values array only. <br> <br> The following example shows a patch operation removing a single value from "customAttributeNameA"  and multiple values from "customAttributeNameB": <br>  <table> <tr><td> {  "schemas":["urn:ietf:params:scim:api:messages:2.0:PatchOp"], "Operations":  [    {      "op":"remove",      "path":"urn:ietf:params:scim:schemas:extension:ibm:2.0:User:customAttributes[name eq "customAttributeNameA"].values",      "value":"customAttributeValueToRemoveA1"    },    {      "op":"remove",      "path":"urn:ietf:params:scim:schemas:extension:ibm:2.0:User:customAttributes[name eq "customAttributeNameB"].values",      "value":          [             "customAttributeValueToRemoveB1",             "customAttributeValueToRemoveB2"          ]    }  ]}</td></tr></table>
	Value *interface{} `json:"value,omitempty"`
}

// PatchOperation0Op The operation to be performed.
type PatchOperation0Op string

// PatchSingleAttributeReqModel defines model for PatchSingleAttributeReqModel.
type PatchSingleAttributeReqModel struct {
	// CredName The name of the attribute in the login session credentials. Maximum length is 2048 characters
	CredName *string `json:"credName,omitempty"`

	// CredNameOverrides Realm specific name of the attribute in the login session credentials. This property is specified in the form of key-value pairs where the key is the name of the realm  and the value is the name of the attribute used to override the 'credName' property. Maximum length is 2048 characters
	CredNameOverrides *map[string]string `json:"credNameOverrides,omitempty"`

	// CustomProperties Identifies the attribute custom properties that is attached to this attribute. These custom properties can be any user-defined key-value pairs that help identify or categorize the attribute. The maximum number of custom properties that can be defined is 25
	CustomProperties *map[string]string `json:"customProperties,omitempty"`

	// Datatype The type of derived data that is expected for the attribute. Defaults to string
	Datatype *PatchSingleAttributeReqModelDatatype `json:"datatype,omitempty"`

	// Description The description of the attribute. Maximum length is 2048 characters
	Description *string   `json:"description,omitempty"`
	Function    *Function `json:"function,omitempty"`

	// Name The human-readable name of the attribute. Maximum length is 2048 characters
	Name *string `json:"name,omitempty"`

	// SourceType The type of the attribute source from which the attribute value is derived
	SourceType *PatchSingleAttributeReqModelSourceType `json:"sourceType,omitempty"`

	// Tags The tags used to categorize attributes. Maximum number of tags is 25
	Tags *[]string `json:"tags,omitempty"`

	// Value The default value of the attribute. This value also refers to the fixed value for sourceType="static". Maximum length is 2048 characters
	Value *string `json:"value,omitempty"`
}

// PatchSingleAttributeReqModelDatatype The type of derived data that is expected for the attribute. Defaults to string
type PatchSingleAttributeReqModelDatatype string

// PatchSingleAttributeReqModelSourceType The type of the attribute source from which the attribute value is derived
type PatchSingleAttributeReqModelSourceType string

// PhoneNumber defines model for PhoneNumber.
type PhoneNumber struct {
	// Type A label that indicates the attribute's function; for example, "work" or "home".
	Type PhoneNumberType `json:"type"`

	// Value A list of phone numbers that are associated with the user. The value is be canonicalized by the service provider according to format in RFC3966, for example, "tel:+1-201-555-0123". Canonical type values are work, home, mobile, fax, and pager. Maximum length is 32 characters.
	Value string `json:"value"`
}

// PhoneNumberType A label that indicates the attribute's function; for example, "work" or "home".
type PhoneNumberType string

// PlanIdentifierTuple defines model for PlanIdentifierTuple.
type PlanIdentifierTuple struct {
	PlanID  *string `json:"planId,omitempty"`
	Set     *bool   `json:"set,omitempty"`
	Version *int32  `json:"version,omitempty"`
}

// PlanPackage defines model for PlanPackage.
type PlanPackage struct {
	AffectedPlans             *map[string][]PlanIdentifierTuple  `json:"affectedPlans,omitempty"`
	APIDescription            *string                            `json:"apiDescription,omitempty"`
	APIEndpoint               *string                            `json:"apiEndpoint,omitempty"`
	APIID                     *string                            `json:"apiId,omitempty"`
	APIName                   *string                            `json:"apiName,omitempty"`
	APIVersion                *string                            `json:"apiVersion,omitempty"`
	CreatedAt                 *time.Time                         `json:"createdAt,omitempty"`
	CreatedBy                 *string                            `json:"createdBy,omitempty"`
	Dependents                *map[string][]PlanPackage          `json:"dependents,omitempty"`
	DeploymentPackageID       *string                            `json:"deploymentPackageId,omitempty"`
	DeploymentState           *PlanPackageDeploymentState        `json:"deploymentState,omitempty"`
	DeploymentVisibility      *DeploymentVisibility              `json:"deploymentVisibility,omitempty"`
	Document                  *ConfigDataObject                  `json:"document,omitempty"`
	DocumentID                *string                            `json:"documentId,omitempty"`
	DocumentType              *PlanPackageDocumentType           `json:"documentType,omitempty"`
	DocumentVersion           *int32                             `json:"documentVersion,omitempty"`
	EnvID                     *string                            `json:"envId,omitempty"`
	ID                        *string                            `json:"id,omitempty"`
	OperationStatusSummary    *OperationStatusSummary            `json:"operationStatusSummary,omitempty"`
	OrgID                     *string                            `json:"orgId,omitempty"`
	PendingDeploymentState    *PlanPackagePendingDeploymentState `json:"pendingDeploymentState,omitempty"`
	PlanDescription           *string                            `json:"planDescription,omitempty"`
	PlanDisplayName           *string                            `json:"planDisplayName,omitempty"`
	PlanID                    *string                            `json:"planId,omitempty"`
	PlanName                  *string                            `json:"planName,omitempty"`
	PlanRegistrations         *int64                             `json:"planRegistrations,omitempty"`
	PlanRequiresApproval      *bool                              `json:"planRequiresApproval,omitempty"`
	PlanVersion               *int32                             `json:"planVersion,omitempty"`
	ProductName               *string                            `json:"productName,omitempty"`
	ProductVersion            *string                            `json:"productVersion,omitempty"`
	ProductVisibilityMetadata *ProductPackageUpdateJSONBody      `json:"productVisibilityMetadata,omitempty"`
	SupersededBy              *PlanIdentifierTuple               `json:"supersededBy,omitempty"`
	Supersedes                *PlanIdentifierTuple               `json:"supersedes,omitempty"`
	Task                      *TaskListGetResponse               `json:"task,omitempty"`
	TaskID                    *string                            `json:"taskId,omitempty"`
	UpdatedAt                 *time.Time                         `json:"updatedAt,omitempty"`
	UpdatedBy                 *string                            `json:"updatedBy,omitempty"`
	URL                       *string                            `json:"url,omitempty"`
	VendorExtensions          *map[string]map[string]interface{} `json:"vendorExtensions,omitempty"`
}

// PlanPackageDeploymentState defines model for PlanPackage.DeploymentState.
type PlanPackageDeploymentState string

// PlanPackageDocumentType defines model for PlanPackage.DocumentType.
type PlanPackageDocumentType string

// PlanPackagePendingDeploymentState defines model for PlanPackage.PendingDeploymentState.
type PlanPackagePendingDeploymentState string

// PolicyMetadata Metadata for a policy
type PolicyMetadata struct {
	// Created The time when this revision was created
	Created *int64 `json:"created,omitempty"`

	// CreatedBy The user who created this revision
	CreatedBy       *string                        `json:"createdBy,omitempty"`
	EnforcementType *PolicyMetadataEnforcementType `json:"enforcementType,omitempty"`

	// Label A label for the revision
	Label *string `json:"label,omitempty"`

	// LastActive When was this revision's state last 'ACTIVE'
	LastActive *int64 `json:"lastActive,omitempty"`

	// Modified The time when this revision was last modified
	Modified *int64 `json:"modified,omitempty"`

	// ModifiedBy The user who last modified this revision
	ModifiedBy *string `json:"modifiedBy,omitempty"`

	// Predefined Is the policy predefined
	Predefined *bool `json:"predefined,omitempty"`

	// ReferencedBy Which policies reference this policy
	ReferencedBy *[]int64 `json:"referencedBy,omitempty"`

	// References Which policies does this policy reference
	References *[]int64 `json:"references,omitempty"`

	// Revision The revision number for this policy
	Revision *int32 `json:"revision,omitempty"`

	// Schema The schema version of this policy
	Schema *string `json:"schema,omitempty"`

	// Scope Which scopes are permitted to apply this policy
	Scope *[]PolicyMetadataScope `json:"scope,omitempty"`

	// State The state of the revision
	State PolicyMetadataState `json:"state"`

	// TenantDefaultPolicy should this policy be the default
	TenantDefaultPolicy *bool `json:"tenantDefaultPolicy,omitempty"`
}

// PolicyMetadataEnforcementType defines model for PolicyMetadata.EnforcementType.
type PolicyMetadataEnforcementType string

// PolicyMetadataScope defines model for PolicyMetadata.Scope.
type PolicyMetadataScope string

// PolicyMetadataState The state of the revision
type PolicyMetadataState string

// PolicyValidations defines model for PolicyValidations.
type PolicyValidations struct {
	SubscriptionsNeeded *[]string `json:"subscriptionsNeeded,omitempty"`
}

// PolicyVaultList0 A paginated list of policies
type PolicyVaultList0 struct {
	// Count The  number of resources returned
	Count int32 `json:"count"`

	// Limit The limit of the number of resources
	Limit int32 `json:"limit"`

	// Page The current page of results
	Page     int32      `json:"page"`
	Policies *[]Policy0 `json:"policies,omitempty"`

	// Total The total number of resources found
	Total int32 `json:"total"`
}

// Policy0 A policy
type Policy0 struct {
	// Description The description of the policy
	Description *string `json:"description,omitempty"`

	// ID The policy identifier
	ID *int64 `json:"id,omitempty"`

	// Meta Metadata for a policy
	Meta *PolicyMetadata `json:"meta,omitempty"`

	// Name The name of the policy
	Name                  string               `json:"name"`
	RequiredSubscriptions *[]string            `json:"requiredSubscriptions,omitempty"`
	Rules                 *[]AccessPolicyRule0 `json:"rules,omitempty"`
	Validations           *PolicyValidations   `json:"validations,omitempty"`
}

// PostEval defines model for PostEval.
type PostEval struct {
	// Custom A custom rule for transforming. This will tranform the attribute mapping. Only one of 'id' or 'custom' can be set on an attribute mapping.
	Custom string `json:"custom"`

	// ID A valid attribute function. This will tranform the attribute mapping. Only one of 'id' or 'custom' can be set on an attribute mapping.
	ID string `json:"id"`
}

// PrintWriter defines model for PrintWriter.
type PrintWriter = map[string]interface{}

// ProductPackageUpdateJSONBody defines model for ProductPackageUpdateJsonBody.
type ProductPackageUpdateJSONBody struct {
	Visibility *DeploymentVisibility `json:"visibility,omitempty"`
}

// ProfileAttribute defines model for ProfileAttribute.
type ProfileAttribute struct {
	// Name The name of the attribute in the application profile.
	Name string `json:"name"`
}

// ResultSet defines model for ResultSet.
type ResultSet struct {
	AfterLast      *bool              `json:"afterLast,omitempty"`
	BeforeFirst    *bool              `json:"beforeFirst,omitempty"`
	Closed         *bool              `json:"closed,omitempty"`
	Concurrency    *int32             `json:"concurrency,omitempty"`
	CursorName     *string            `json:"cursorName,omitempty"`
	FetchDirection *int32             `json:"fetchDirection,omitempty"`
	FetchSize      *int32             `json:"fetchSize,omitempty"`
	First          *bool              `json:"first,omitempty"`
	Holdability    *int32             `json:"holdability,omitempty"`
	Last           *bool              `json:"last,omitempty"`
	MetaData       *ResultSetMetaData `json:"metaData,omitempty"`
	Row            *int32             `json:"row,omitempty"`
	Statement      *Statement         `json:"statement,omitempty"`
	Type           *int32             `json:"type,omitempty"`
	Warnings       *SQLWarning        `json:"warnings,omitempty"`
}

// ResultSetMetaData defines model for ResultSetMetaData.
type ResultSetMetaData struct {
	ColumnCount *int32 `json:"columnCount,omitempty"`
}

// SQLException defines model for SQLException.
type SQLException struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	ErrorCode        *int32               `json:"errorCode,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	NextException    *SQLException        `json:"nextException,omitempty"`
	Sqlstate         *string              `json:"sqlstate,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// SQLWarning defines model for SQLWarning.
type SQLWarning struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	ErrorCode        *int32               `json:"errorCode,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	NextException    *SQLException        `json:"nextException,omitempty"`
	NextWarning      *SQLWarning          `json:"nextWarning,omitempty"`
	Sqlstate         *string              `json:"sqlstate,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// SchemaAttribute defines model for SchemaAttribute.
type SchemaAttribute struct {
	// AttributeName The attribute name in the schema that is associated with the attribute source
	AttributeName string `json:"attributeName"`

	// CustomAttribute The flag that indicates whether this is a custom attribute
	CustomAttribute bool `json:"customAttribute"`

	// Name The unique name for the attribute in the Cloud Directory schema. For custom schema attributes, the names are predefined and named customAttribute1 through customAttribute150
	Name string `json:"name"`

	// ScimName The SCIM name that is associated with the schema attribute
	ScimName string `json:"scimName"`
}

// ServerSideAction The server side actions for the policy
type ServerSideAction struct {
	ActionID *string `json:"actionId,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// ServletContext defines model for ServletContext.
type ServletContext struct {
	AttributeNames                *EnumerationString                             `json:"attributeNames,omitempty"`
	ClassLoader                   *ClassLoader                                   `json:"classLoader,omitempty"`
	ContextPath                   *string                                        `json:"contextPath,omitempty"`
	DefaultSessionTrackingModes   *[]ServletContextDefaultSessionTrackingModes   `json:"defaultSessionTrackingModes,omitempty"`
	EffectiveMajorVersion         *int32                                         `json:"effectiveMajorVersion,omitempty"`
	EffectiveMinorVersion         *int32                                         `json:"effectiveMinorVersion,omitempty"`
	EffectiveSessionTrackingModes *[]ServletContextEffectiveSessionTrackingModes `json:"effectiveSessionTrackingModes,omitempty"`
	FilterRegistrations           *map[string]FilterRegistration                 `json:"filterRegistrations,omitempty"`
	InitParameterNames            *EnumerationString                             `json:"initParameterNames,omitempty"`
	JspConfigDescriptor           *JspConfigDescriptor                           `json:"jspConfigDescriptor,omitempty"`
	MajorVersion                  *int32                                         `json:"majorVersion,omitempty"`
	MinorVersion                  *int32                                         `json:"minorVersion,omitempty"`
	ServerInfo                    *string                                        `json:"serverInfo,omitempty"`
	ServletContextName            *string                                        `json:"servletContextName,omitempty"`
	ServletNames                  *EnumerationString                             `json:"servletNames,omitempty"`
	ServletRegistrations          *map[string]ServletRegistration                `json:"servletRegistrations,omitempty"`
	Servlets                      *EnumerationServlet                            `json:"servlets,omitempty"`
	SessionCookieConfig           *SessionCookieConfig                           `json:"sessionCookieConfig,omitempty"`
	VirtualServerName             *string                                        `json:"virtualServerName,omitempty"`
}

// ServletContextDefaultSessionTrackingModes defines model for ServletContext.DefaultSessionTrackingModes.
type ServletContextDefaultSessionTrackingModes string

// ServletContextEffectiveSessionTrackingModes defines model for ServletContext.EffectiveSessionTrackingModes.
type ServletContextEffectiveSessionTrackingModes string

// ServletInputStream defines model for ServletInputStream.
type ServletInputStream struct {
	Finished *bool `json:"finished,omitempty"`
	Ready    *bool `json:"ready,omitempty"`
}

// ServletOutputStream defines model for ServletOutputStream.
type ServletOutputStream struct {
	Ready *bool `json:"ready,omitempty"`
}

// ServletRegistration defines model for ServletRegistration.
type ServletRegistration struct {
	ClassName      *string            `json:"className,omitempty"`
	InitParameters *map[string]string `json:"initParameters,omitempty"`
	Mappings       *[]string          `json:"mappings,omitempty"`
	Name           *string            `json:"name,omitempty"`
	RunAsRole      *string            `json:"runAsRole,omitempty"`
}

// ServletRequest defines model for ServletRequest.
type ServletRequest struct {
	AsyncContext      *AsyncContext                 `json:"asyncContext,omitempty"`
	AsyncStarted      *bool                         `json:"asyncStarted,omitempty"`
	AsyncSupported    *bool                         `json:"asyncSupported,omitempty"`
	AttributeNames    *EnumerationString            `json:"attributeNames,omitempty"`
	CharacterEncoding *string                       `json:"characterEncoding,omitempty"`
	ContentLength     *int32                        `json:"contentLength,omitempty"`
	ContentLengthLong *int64                        `json:"contentLengthLong,omitempty"`
	ContentType       *string                       `json:"contentType,omitempty"`
	DispatcherType    *ServletRequestDispatcherType `json:"dispatcherType,omitempty"`
	InputStream       *ServletInputStream           `json:"inputStream,omitempty"`
	LocalAddr         *string                       `json:"localAddr,omitempty"`
	LocalName         *string                       `json:"localName,omitempty"`
	LocalPort         *int32                        `json:"localPort,omitempty"`
	Locale            *Locale                       `json:"locale,omitempty"`
	Locales           *EnumerationLocale            `json:"locales,omitempty"`
	ParameterMap      *map[string][]string          `json:"parameterMap,omitempty"`
	ParameterNames    *EnumerationString            `json:"parameterNames,omitempty"`
	Protocol          *string                       `json:"protocol,omitempty"`
	Reader            *BufferedReader               `json:"reader,omitempty"`
	RemoteAddr        *string                       `json:"remoteAddr,omitempty"`
	RemoteHost        *string                       `json:"remoteHost,omitempty"`
	RemotePort        *int32                        `json:"remotePort,omitempty"`
	Scheme            *string                       `json:"scheme,omitempty"`
	Secure            *bool                         `json:"secure,omitempty"`
	ServerName        *string                       `json:"serverName,omitempty"`
	ServerPort        *int32                        `json:"serverPort,omitempty"`
	ServletContext    *ServletContext               `json:"servletContext,omitempty"`
}

// ServletRequestDispatcherType defines model for ServletRequest.DispatcherType.
type ServletRequestDispatcherType string

// ServletResponse defines model for ServletResponse.
type ServletResponse struct {
	BufferSize        *int32               `json:"bufferSize,omitempty"`
	CharacterEncoding *string              `json:"characterEncoding,omitempty"`
	Committed         *bool                `json:"committed,omitempty"`
	ContentType       *string              `json:"contentType,omitempty"`
	Locale            *Locale              `json:"locale,omitempty"`
	OutputStream      *ServletOutputStream `json:"outputStream,omitempty"`
	Writer            *PrintWriter         `json:"writer,omitempty"`
}

// SessionCookieConfig defines model for SessionCookieConfig.
type SessionCookieConfig struct {
	Comment  *string `json:"comment,omitempty"`
	Domain   *string `json:"domain,omitempty"`
	HTTPOnly *bool   `json:"httpOnly,omitempty"`
	MaxAge   *int32  `json:"maxAge,omitempty"`
	Name     *string `json:"name,omitempty"`
	Path     *string `json:"path,omitempty"`
	Secure   *bool   `json:"secure,omitempty"`
}

// StackTraceElement defines model for StackTraceElement.
type StackTraceElement struct {
	ClassName    *string `json:"className,omitempty"`
	FileName     *string `json:"fileName,omitempty"`
	LineNumber   *int32  `json:"lineNumber,omitempty"`
	MethodName   *string `json:"methodName,omitempty"`
	NativeMethod *bool   `json:"nativeMethod,omitempty"`
}

// Statement defines model for Statement.
type Statement struct {
	CloseOnCompletion    *bool       `json:"closeOnCompletion,omitempty"`
	Closed               *bool       `json:"closed,omitempty"`
	Connection           *Connection `json:"connection,omitempty"`
	FetchDirection       *int32      `json:"fetchDirection,omitempty"`
	FetchSize            *int32      `json:"fetchSize,omitempty"`
	GeneratedKeys        *ResultSet  `json:"generatedKeys,omitempty"`
	LargeMaxRows         *int64      `json:"largeMaxRows,omitempty"`
	LargeUpdateCount     *int64      `json:"largeUpdateCount,omitempty"`
	MaxFieldSize         *int32      `json:"maxFieldSize,omitempty"`
	MaxRows              *int32      `json:"maxRows,omitempty"`
	MoreResults          *bool       `json:"moreResults,omitempty"`
	Poolable             *bool       `json:"poolable,omitempty"`
	QueryTimeout         *int32      `json:"queryTimeout,omitempty"`
	ResultSet            *ResultSet  `json:"resultSet,omitempty"`
	ResultSetConcurrency *int32      `json:"resultSetConcurrency,omitempty"`
	ResultSetHoldability *int32      `json:"resultSetHoldability,omitempty"`
	ResultSetType        *int32      `json:"resultSetType,omitempty"`
	UpdateCount          *int32      `json:"updateCount,omitempty"`
	Warnings             *SQLWarning `json:"warnings,omitempty"`
}

// Subscribe defines model for Subscribe.
type Subscribe struct {
	// Enabled Is the plan visible.
	Enabled bool `json:"enabled"`

	// Orgs When subscribe is custom: The Organizations allowed to subscribe.
	Orgs *[]string `json:"orgs,omitempty"`

	// Tags When subscribe is custom: The Communities allowed to subscribe.
	Tags *[]string     `json:"tags,omitempty"`
	Type SubscribeType `json:"type"`
}

// SubscribeType defines model for Subscribe.Type.
type SubscribeType string

// TaglibDescriptor defines model for TaglibDescriptor.
type TaglibDescriptor struct {
	TaglibLocation *string `json:"taglibLocation,omitempty"`
	TaglibURI      *string `json:"taglibURI,omitempty"`
}

// TaskActivityResponse defines model for TaskActivityResponse.
type TaskActivityResponse struct {
	// Action The action executed by this activity
	Action *map[string]interface{} `json:"action,omitempty"`

	// Comment The user's comment for this action
	Comment *string `json:"comment,omitempty"`

	// Date The date this action was executed
	Date *time.Time `json:"date,omitempty"`

	// DisplayName The display name of the user who initiated this action
	DisplayName *string `json:"displayName,omitempty"`

	// UserID The id of the user who initiated this action
	UserID *string `json:"userId,omitempty"`

	// Username The username of the user who initiated this action
	Username *string `json:"username,omitempty"`
}

// TaskListGetResponse defines model for TaskListGetResponse.
type TaskListGetResponse struct {
	Activities       []TaskActivityResponse      `json:"activities"`
	AvailableActions []string                    `json:"availableActions"`
	EnvID            string                      `json:"envId"`
	ID               string                      `json:"id"`
	OrgID            string                      `json:"orgId"`
	Status           TaskListGetResponseStatus   `json:"status"`
	TaskProperties   *string                     `json:"taskProperties,omitempty"`
	TaskType         TaskListGetResponseTaskType `json:"taskType"`
	URL              string                      `json:"url"`
}

// TaskListGetResponseStatus defines model for TaskListGetResponse.Status.
type TaskListGetResponseStatus string

// TaskListGetResponseTaskType defines model for TaskListGetResponse.TaskType.
type TaskListGetResponseTaskType string

// TemplateError defines model for TemplateError.
type TemplateError struct {
	MessageDescription *string `json:"messageDescription,omitempty"`
	MessageID          *string `json:"messageId,omitempty"`
}

// TemporalUnit defines model for TemporalUnit.
type TemporalUnit struct {
	DateBased         *bool     `json:"dateBased,omitempty"`
	Duration          *Duration `json:"duration,omitempty"`
	DurationEstimated *bool     `json:"durationEstimated,omitempty"`
	TimeBased         *bool     `json:"timeBased,omitempty"`
}

// ThemeRegistrationPaginatedResponseContainer defines model for ThemeRegistrationPaginatedResponseContainer.
type ThemeRegistrationPaginatedResponseContainer struct {
	Count              *int32                    `json:"count,omitempty"`
	Limit              *int32                    `json:"limit,omitempty"`
	Page               *int32                    `json:"page,omitempty"`
	ThemeRegistrations *[]map[string]interface{} `json:"themeRegistrations,omitempty"`
	Total              *int32                    `json:"total,omitempty"`
}

// Throwable defines model for Throwable.
type Throwable struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	// ActorToken The token identifying the acting party in a token exchange flow.
	ActorToken *string `json:"actor_token,omitempty"`

	// ActorTokenType The token type of the actor_token.
	ActorTokenType *interface{} `json:"actor_token_type,omitempty"`

	// ClientAssertion The JWT assertion being used to authenticate the client.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType The format of client assertion.
	ClientAssertionType *TokenRequestClientAssertionType `json:"client_assertion_type,omitempty"`

	// ClientID The OIDC client ID that is required when the basic authorization header is not set.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret The OIDC client secret that is required when the basic authorization header is not set and the client is not a public client.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Code The authorization code. It is only required for "authorization_code" grant types.
	Code *string `json:"code,omitempty"`

	// CodeVerifier The code verifier. This is used to verify the code challenge that was sent at the authorize endpoint. Required if the OIDC client is configured to require proof key for code exchange (PKCE)
	CodeVerifier *string `json:"code_verifier,omitempty"`

	// GrantType The grant type.
	GrantType TokenRequestGrantType `json:"grant_type"`

	// Password The password credential of resource owner. It is only required for "password" grant types.
	Password *string `json:"password,omitempty"`

	// RedirectURI The redirect URI. It is only required for "authorization_code" grant types.
	RedirectURI *string `json:"redirect_uri,omitempty"`

	// RefreshToken The refresh token. It is only required for "refresh_token" grant types.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// RequestedTokenType The type of token that should be returned as part of the token exchange flow.
	RequestedTokenType *string `json:"requested_token_type,omitempty"`

	// Scope A space-delimited list of scopes that are associated with generated access token.
	Scope *string `json:"scope,omitempty"`

	// SubjectToken The token identifying the subject for a token exchange flow.
	SubjectToken *string `json:"subject_token,omitempty"`

	// SubjectTokenType The token type of the subject_token.
	SubjectTokenType *string `json:"subject_token_type,omitempty"`

	// Username The user credential of resource owner. It is only required for "password" grant types.
	Username *string `json:"username,omitempty"`
}

// TokenRequestClientAssertionType The format of client assertion.
type TokenRequestClientAssertionType string

// TokenRequestGrantType The grant type.
type TokenRequestGrantType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// AccessToken The access token that is issued by the authorization server.
	AccessToken string `json:"access_token"`

	// ExpiresIn The lifetime, in seconds, of the access token.
	ExpiresIn int32 `json:"expires_in"`

	// GrantID The grant identifier of this authorization grant.
	GrantID string `json:"grant_id"`

	// IDToken The ID token that is issued by the authorization server, when the requested scope contains 'openid'.
	IDToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token that is used to obtain new access tokens. It is only available for authorization_code grant if the refresh_token grant is enabled.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope A space-delimited list of scopes that are associated with this access token.
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the access token.
	TokenType string `json:"token_type"`
}

// TransformBody TransformBody is either a valid UTF-8 string, or a valid JSON object
type TransformBody struct {
	JSON *map[string]map[string]interface{} `json:"JSON,omitempty"`
	Raw  *[]uint8                           `json:"Raw,omitempty"`
}

// TransformObject defines model for TransformObject.
type TransformObject struct {
	// AuthenticationHeader AuthenticationHeader is an outgoing transform parameter.
	AuthenticationHeader *map[string]string `json:"authentication_header,omitempty"`

	// Body TransformBody is either a valid UTF-8 string, or a valid JSON object
	Body *TransformBody `json:"body,omitempty"`

	// Header The keys should be in canonical form, as returned by
	// CanonicalHeaderKey.
	Header *Header `json:"header,omitempty"`

	// Host Host is an outgoing transform parameter, and will only be populated in webhook usage when all the URLs configured have a consistent host
	Host *string `json:"host,omitempty"`

	// Method Method is an outgoing transform parameter.
	Method *string `json:"method,omitempty"`

	// Path Path is an outgoing transform parameter.
	Path    *string          `json:"path,omitempty"`
	Request *TransformObject `json:"request,omitempty"`

	// StatusCode StatusCode is an incoming transform parameter.
	StatusCode *int64 `json:"statusCode,omitempty"`
}

// Unauthorized1 The message response to the given request
type Unauthorized1 struct {
	// MessageDescription Requester locale specific descriptive message.
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier.
	MessageID string `json:"messageId"`
}

// UserGroupV1 Represents a user group
type UserGroupV1 struct {
	Description *string `json:"description,omitempty"`
	Email       *string `json:"email,omitempty"`
	FamilyName  *string `json:"familyName,omitempty"`
	Formatted   *string `json:"formatted,omitempty"`
	GivenName   *string `json:"givenName,omitempty"`
	ID          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Realm       *string `json:"realm,omitempty"`
	UserType    *string `json:"userType,omitempty"`
}

// UserResponseV2 defines model for UserResponseV2.
type UserResponseV2 struct {
	// Active A Boolean value that indicates the user's administrative status. The definitive meaning of this attribute is determined by the service provider. For example, a value of true indicates that the user can, log in, while a value of false indicates that the user's account has been suspended. If not specified, the value defaults to true.
	Active *bool `json:"active,omitempty"`

	// Addresses A list of addresses that are associated with the user.
	Addresses []Address `json:"addresses"`

	// DisplayName The name of the user that is displayed to users. Each user returned may include a non-empty displayName value. Typically it is the full name of the user being described, for example, Babs Jensen or Ms. Barbara J Jensen. However, if that information is unavailable, a username or handle can be used, for example, bjensen. The value is the primary textual label by which this user is normally displayed by the service provider when presenting information to users.
	DisplayName *string `json:"displayName,omitempty"`

	// Emails A list of email addresses that are associated with the user. Only one is supported.
	Emails []EmailAddress `json:"emails"`

	// ExternalID A unique identifier for the resource that is defined by the provisioning client. It identifies a resource between the provisioning client and the service provider. The client can use a filter to locate the resource with an identifier from the provisioning domain.
	ExternalID *string `json:"externalId,omitempty"`

	// Groups The list of groups that the user belongs to. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored. Group membership is managed by using the /Groups API.
	Groups *[]Groups `json:"groups,omitempty"`

	// ID The unique identifier for the resource as defined by the service. This attribute is read-only and ise sent by the service. Any value that is specified for this attribute in the JSON POST or PUT request payload is ignored.
	ID   string  `json:"id"`
	Meta *MetaV2 `json:"meta,omitempty"`
	Name Name    `json:"name"`

	// PhoneNumbers A list of phone numbers that are associated with the user.
	PhoneNumbers *[]PhoneNumber `json:"phoneNumbers,omitempty"`

	// PreferredLanguage The language code identifying the preferred language of this identity, for example, en-us or fr-ca.
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure. The schemas "urn:ietf:params:scim:schemas:core:2.0:User", "urn:ietf:params:scim:schemas:extension:ibm:2.0:User" and "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User" are returned in the response.
	Schemas []string `json:"schemas"`

	// Title The user's title, such as "Vice President."
	Title                                             *string                `json:"title,omitempty"`
	UrnIetfParamsScimSchemasExtensionEnterprise20User *EnterpriseUser        `json:"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20User        *CICCustomUserResponse `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:User,omitempty"`

	// UserName The unique identifier for the user that is typically used by the user to directly authenticate to the service provider. It is often displayed to the user as their unique identifier within the system (as opposed to the id or externalId attributes, which are generally opaque and not user-friendly identifiers). Each user must include a non-empty userName value. This identifier must be unique across the service consumer's entire set of users. It must be a stable ID that does not change when the same user is returned in subsequent requests.
	UserName string `json:"userName"`
}

// UserV2 defines model for UserV2.
type UserV2 struct {
	// Active A Boolean value that indicates the user's administrative status. The definitive meaning of this attribute is determined by the service provider. For example, a value of true indicates that the user can log in, while a value of false indicates that the user's account has been suspended. If not specified, the value defaults to true.
	Active *bool `json:"active,omitempty"`

	// Addresses A list of addresses that can be used to create a user.
	Addresses *[]Address `json:"addresses,omitempty"`

	// DisplayName The name of the user that is displayed to users. Each user returned may include a non-empty displayName value. Typically it is the full name of the user that is being described, for example, Babs Jensen or Ms. Barbara J Jensen. However, if that information is unavailable, a username or handle can be used, for example, bjensen. The value is the primary textual label by which this User is normally displayed by the service provider when presenting information to users. Maximum length is 128 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Emails A list of email addresses that can be used to create a user.
	Emails *[]EmailAddress `json:"emails,omitempty"`

	// ExternalID The unique identifier for the resource that is defined by the provisioning client. It identifies a resource between the provisioning client and the service provider. The client can use a filter to locate the resource with that identifier from the provisioning domain. Maximum length is 240 characters.
	ExternalID *string `json:"externalId,omitempty"`
	Name       *Name   `json:"name,omitempty"`

	// Password The user's clear text password. This attribute is used to specify an initial password when a new user is created or to reset an existing user's password. Maximum length is 4096 characters. If the password contains extended ASCII characters then you must add charset=utf-8 in the Content-Type header when making a REST API call. Cannot begin with the > character and end with the < character.
	Password *string `json:"password,omitempty"`

	// PhoneNumbers A list of phone numbers that can be used to create a user.
	PhoneNumbers *[]PhoneNumber `json:"phoneNumbers,omitempty"`

	// PreferredLanguage The language code identifying the preferred language of this identity, for example, en-us or fr-ca. Maximum length is 5 characters.
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`

	// Schemas An array of strings that contain the URIs that indicate the namespaces of the SCIM schemas that define the attributes in the current JSON structure.
	//   The schemas ""urn:ietf:params:scim:schemas:core:2.0:User", "urn:ietf:params:scim:schemas:extension:ibm:2.0:User", "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User" and "urn:ietf:params:scim:schemas:extension:ibm:2.0:Notification" are valid.  The core user schema is required.
	Schemas []string `json:"schemas"`

	// Title The user's title, such as "Vice President." Maximum length is 128 characters.
	Title                                              *string         `json:"title,omitempty"`
	UrnIetfParamsScimSchemasExtensionEnterprise20User  *EnterpriseUser `json:"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20Notification *Notifications  `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:Notification,omitempty"`
	UrnIetfParamsScimSchemasExtensionIbm20User         *CICCustomUser  `json:"urn:ietf:params:scim:schemas:extension:ibm:2.0:User,omitempty"`

	// UserName The unique identifier for the user that is typically used by the user to directly authenticate to the service provider. It is often displayed to the user as their unique identifier within the system (as opposed to the id or externalId attributes, which are generally opaque and not user-friendly identifiers). Each user must include a non-empty userName value. This identifier must be unique across the service consumer's entire set of Users. It must be a stable ID that does not change when the same user is returned in subsequent requests.  Maximum length is 256 characters.
	UserName string `json:"userName"`
}

// ValueConstraint defines model for ValueConstraint.
type ValueConstraint struct {
	Format *string                 `json:"format,omitempty"`
	Type   *string                 `json:"type,omitempty"`
	Value  *map[string]interface{} `json:"value,omitempty"`
}

// View defines model for View.
type View struct {
	// Enabled Is the plan visible.
	Enabled bool `json:"enabled"`

	// Orgs When view is custom: The Organizations allowed to view this plan.
	Orgs *[]string `json:"orgs,omitempty"`

	// Tags When view is custom: The Communities allowed to view this plan.
	Tags *[]string `json:"tags,omitempty"`
	Type ViewType  `json:"type"`
}

// ViewType defines model for View.Type.
type ViewType string

// PostOauth2TokenParams defines parameters for PostOauth2Token.
type PostOauth2TokenParams struct {
	// Authorization The basic authorization header that contains a base64-encoded client ID and the client secret. Use this header as an alternative to sending the client ID and secret in the form parameters.
	Authorization *string `json:"Authorization,omitempty"`
}

// GetAPIClientsParams defines parameters for GetAPIClients.
type GetAPIClientsParams struct {
	// Pagination The prefix for the paging parameter is "pagination=". If no pagination parameters are passed in, all results are returned. The maximum allowed value for limit or count is 1000. <br><b>count</b> is the total number of results to be returned from the data store.<br><b>page</b> is which page we are requesting, or the offset. <br><b>limit</b> is the total number of results to return in one page.<br><br>The pagination parameter value <b>must</b> be HTML encoded.<br>Note: This is not required when using the Swagger UI.<br><br><b>Example:</b> Paginate on count=10&page=1&limit=5<br>pagination=count%3D10%26page%3D1%26limit%3D5
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Sort The prefix for the sort parameter is "sort=". Each attribute must be prefixed with either + or - (+ ascending, - descending). Multiple attributes must be separated by a comma (,).<br><br>The valid fields for sorting are: clientId, clientName, and enabled.<br><br>The sort parameter value <b>must</b> be HTML encoded.<br>Note: This is not required when using the Swagger UI.<br><br><b>Example:</b> Sort on -enabled,+clientId<br>sort=-enabled%2C%2BclientId
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Search The prefix for all search operations is "search=".<br>Valid operators for strings are = , !=  and contains <br>Valid operators for booleans are = and !=<br>Valid operators for numbers are >=, >, &lt=, &lt, = and !=<br>String search values must be double quoted, numbers and booleans must not.<br><br>The valid fields for sorting are: clientId, clientName, and enabled.<br><br>The search parameter value <b>must</b> be HTML encoded.<br>Note: This is not required when using the Swagger UI.<br><br><b>Example:</b> Search on clientId contains "ABCDEF"&enabled=true<br>search=clientId%20contains%20%22ABCDEF%22%26enabled%3Dtrue
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Filter The prefix for the filter parameter is "filter="<br>Valid formats are either inclusive only or exclusive only. These must not be intermingled. Multiple filter parameters must be separated by a comma (,).<br><br>The valid fields for filtering are: id, clientId, clientName, clientSecret, entitlements, and enabled.<br><br>The filter parameter value <b>must</b> be HTML encoded.<br>Note: This is not required when using the Swagger UI.<br><br><b>Examples</b><br>Filter to only return clientId:<br>filter=clientId<br><br>Filter to exclude clientSecret and enabled:<br>filter=%21clientSecret,enabled
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// BulkDeleteAPIClientJSONBody defines parameters for BulkDeleteAPIClient.
type BulkDeleteAPIClientJSONBody = []BulkOperation

// GetAllAttributesParams defines parameters for GetAllAttributes.
type GetAllAttributesParams struct {
	// Search Returns results based on the search criteria.<br><br>The format to use the search query parameter is 'search={parameter}{operator}{value}<br><br>The following search parameters are allowed: name, credname, tags, sourcetype, id, scope.<br><br>Parameters name, credname, tags, sourcetype, id, scope only support search by string values.<br><br>Valid operators for string values are =, !=, contains, startswith, endswith, and exists.<br> Only for the 'exists' operator, there is no need to specify search value. <br> And for all rest operators, use double quotation marks for the search values.<br><br>Multiple search conditions can be combined using either the & (AND) or | (OR) operators.<br><br>Conditions in parentheses () have a higher priority and are evaluated first. Without parentheses, & (AND) is evaluated first.<br><b>Example</b>: (tags="sso"|name="email")&id="10"<br><b>Note</b>: Nested parentheses are not supported.<br><br><b>Example</b>: Search for attributes with 'sso' tag: search=tags="sso"<br><b>Example</b>: Search for attributes with name startwith 'pre': search=name%20startswith%20"pre"<br><b>Example</b>: Search for attributes with tag: search=tags%20exists<br>
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Returns sorted results.<br>The following sort parameters are allowed: name, credname, tags, sourcetype, scope.<br>Each sort parameter must be prefixed with either + or -.<br><br><b>Example</b>: Sort attributes by ascending 'name': sort=+name<br>
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Pagination Returns results based on the requested limit and page.<br>The following pagination parameters are allowed: limit, page.<br><br><b>Example</b>: Get only 5 results at the second page: pagination=limit=5%26page=2<br>
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// PatchAttributesParams defines parameters for PatchAttributes.
type PatchAttributesParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// CreateAttributeParams defines parameters for CreateAttribute.
type CreateAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// DeleteAttributeParams defines parameters for DeleteAttribute.
type DeleteAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// GetAttribute0Params defines parameters for GetAttribute0.
type GetAttribute0Params struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// PatchSingleAttributeParams defines parameters for PatchSingleAttribute.
type PatchSingleAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// UpdateAttributeParams defines parameters for UpdateAttribute.
type UpdateAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// GetThemeRegistrationsParams defines parameters for GetThemeRegistrations.
type GetThemeRegistrationsParams struct {
	// Pagination Controls the results that are returned in a page. If no pagination parameters are passed in all results are returned.<br><br>You can use the following query parameters:<br><br><b>count</b> - Use to define the total number of results that are returned from the data store. The maximum allowed value is 1000.<br><br><b>page</b> - Use to identify the requested page, or the offset.<br><br><b>limit</b> - Use to define the total number of results that are returned per page. The maximum allowed value is 1000.<br><br><b>Note</b>: If you are not using the Swagger UI, the pagination parameter value must be HTML encoded. Use the prefix "pagination=" in the query parameter.<br><br><b>Example</b>: Paginate on count=10&page=1&limit=5<br>pagination=count%3D10%26page%3D1%26limit%3D5
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// RegisterThemeTemplatesMultipartBody defines parameters for RegisterThemeTemplates.
type RegisterThemeTemplatesMultipartBody struct {
	// Configuration Theme Registration configuration payload. String-encoded JSON Object.<br><br>Example:<br>{<br>"name": "string",<br>"description": "string (optional)"<br>}<br><br>
	Configuration string `json:"configuration"`

	// Files Customized Template .zip File
	Files openapi_types.File `json:"files"`
}

// DownloadThemeTemplatesParams defines parameters for DownloadThemeTemplates.
type DownloadThemeTemplatesParams struct {
	// CustomizedOnly Includes templates that are customized only. Returns global templates if false
	CustomizedOnly *bool `form:"customized_only,omitempty" json:"customized_only,omitempty"`
}

// UpdateThemeTemplatesMultipartBody defines parameters for UpdateThemeTemplates.
type UpdateThemeTemplatesMultipartBody struct {
	// Configuration Theme Registration configuration payload. String-encoded JSON Object.<br><br>Example:<br>{<br>"name": "string",<br>"description": "string (optional)"<br>}<br><br>
	Configuration string `json:"configuration"`

	// Files Customized Theme .zip File
	Files *openapi_types.File `json:"files,omitempty"`
}

// UpdateThemeTemplateMultipartBody defines parameters for UpdateThemeTemplate.
type UpdateThemeTemplateMultipartBody struct {
	// File Translation Archive File
	File openapi_types.File `json:"file"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Filter The SCIM compliant search filter.  For example, displayName eq "admin". The filter should be no longer than 4096 characters in length.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Attributes The list of attributes that are passed in as comma-separated values that are used when passing the result back to the caller. To improve performance, specify in the list only the attributes that you want returned. If no list is provided, the default action is to return all attributes.
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Count  Specifies the maximum number of query results per page. A negative value is interpreted as 0.  A value of 0 indicates that no resource results are to be returned, except for totalResults.
	Count *string `form:"count,omitempty" json:"count,omitempty"`

	// StartIndex A 1-based index that indicates the start index that is used when the number of groups is returned. A value less than 1 is interpreted as 1.
	StartIndex *string `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// SortBy Sort the results by the specified criteria when the groups are returned.
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder The sorting order when the number of groups is returned.
	SortOrder *GetGroupsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// FullText A string that is searched for in the group records.
	FullText *string `form:"fullText,omitempty" json:"fullText,omitempty"`
}

// GetGroupsParamsSortOrder defines parameters for GetGroups.
type GetGroupsParamsSortOrder string

// CreateGroupParams defines parameters for CreateGroup.
type CreateGroupParams struct {
	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`
}

// DeleteGroupParams defines parameters for DeleteGroup.
type DeleteGroupParams struct {
	// NotifyType An optional query parameter that denotes the notification type.  If not present, the EMAIL notification is used. Specify NONE if no notification to the user is required.
	NotifyType *DeleteGroupParamsNotifyType `form:"notifyType,omitempty" json:"notifyType,omitempty"`

	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`
}

// DeleteGroupParamsNotifyType defines parameters for DeleteGroup.
type DeleteGroupParamsNotifyType string

// GetGroupParams defines parameters for GetGroup.
type GetGroupParams struct {
	// Attributes The list of attributes that are passed in as comma-separated values that are used when passing the result back to the caller. To improve performance, specify in the list only the attributes that you want returned. If no list is provided, the default action is to return all attributes.
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// MembershipType Type of members of the group to retrieve:
	// "firstLevelUsersAndGroups" (default) returns the users and groups directly contained in the group."allNestedUsers" returns all the users (including nested users) contained in the group."firstLevelUsers" returns the users directly contained in the group."firstLevelGroups" returns the groups directly contained in the group.
	MembershipType *GetGroupParamsMembershipType `form:"membershipType,omitempty" json:"membershipType,omitempty"`

	// MemberAttributes The list of attributes that are passed in as comma-separated values for returning the members of the groups when passing the result back to the caller. To improve performance, specify in the list only the attributes that you want returned. If no list is provided, the default action is to return all attributes.
	MemberAttributes *string `form:"memberAttributes,omitempty" json:"memberAttributes,omitempty"`

	// MemberCount The count that indicates the number of members from this group that will be returned. A negative value is interpreted as 0.  A value of 0 indicates that no member results are to be returned, except for totalMembers.
	MemberCount *string `form:"memberCount,omitempty" json:"memberCount,omitempty"`

	// MemberStartIndex A 1-based index that indicates the start index that is used when the members in the group are returned. A value less than 1 is interpreted as 1.
	MemberStartIndex *string `form:"memberStartIndex,omitempty" json:"memberStartIndex,omitempty"`

	// NextPage The bookmark that indicates the next page of members to be returned.
	NextPage *string `form:"nextPage,omitempty" json:"nextPage,omitempty"`
}

// GetGroupParamsMembershipType defines parameters for GetGroup.
type GetGroupParamsMembershipType string

// PatchGroupParams defines parameters for PatchGroup.
type PatchGroupParams struct {
	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`
}

// PutGroupParams defines parameters for PutGroup.
type PutGroupParams struct {
	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Filter The SCIM compliant search filter. For example, userName eq "john". The filter should be no longer than 4096 characters in length.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Attributes The list of attributes that are passed in as comma-separated values that are used when passing the result back to the caller. To improve performance, specify in the list only the attributes that you want returned. If no list is provided, the default action is to return all attributes.
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Count Specifies the maximum number of query results per page. A negative value is interpreted as 0.  A value of 0 indicates that no resource results are to be returned, except for totalResults.
	Count *string `form:"count,omitempty" json:"count,omitempty"`

	// StartIndex A 1-based index that indicates the start index that is used when the number of users is returned. A value less than 1 is interpreted as 1.
	StartIndex *string `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// SortBy Sort the results by the specified criteria when the users are returned.
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder The sorting order when the number of users is returned.
	SortOrder *GetUsersParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Hashed The comma-separated list of attributes whose values are to be hashed.
	Hashed *string `form:"hashed,omitempty" json:"hashed,omitempty"`

	// FullText A string that is searched for in the user records.
	FullText *string `form:"fullText,omitempty" json:"fullText,omitempty"`

	// IncludeGroups Include group information in the response.
	IncludeGroups *string `form:"includeGroups,omitempty" json:"includeGroups,omitempty"`
}

// GetUsersParamsSortOrder defines parameters for GetUsers.
type GetUsersParamsSortOrder string

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Hashed The comma-separated list of attributes whose values are to be hashed.
	Hashed *string `form:"hashed,omitempty" json:"hashed,omitempty"`

	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`

	// Usershouldnotneedtoresetpassword If set to true, the user is not required to change the password after login.<br>Only honored when the password element of UserV2 is set.
	Usershouldnotneedtoresetpassword *CreateUserParamsUsershouldnotneedtoresetpassword `json:"usershouldnotneedtoresetpassword,omitempty"`
}

// CreateUserParamsUsershouldnotneedtoresetpassword defines parameters for CreateUser.
type CreateUserParamsUsershouldnotneedtoresetpassword string

// DeleteUser0Params defines parameters for DeleteUser0.
type DeleteUser0Params struct {
	// NotifyType An optional query parameter that denotes the notification type.  If not present, the EMAIL notification is used. Specify NONE if no notification to the user that their account has been deleted is required.
	NotifyType *DeleteUser0ParamsNotifyType `form:"notifyType,omitempty" json:"notifyType,omitempty"`

	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`
}

// DeleteUser0ParamsNotifyType defines parameters for DeleteUser0.
type DeleteUser0ParamsNotifyType string

// GetUser0Params defines parameters for GetUser0.
type GetUser0Params struct {
	// Attributes The list of attributes that are passed in as comma-separated values that are used when passing the result back to the caller. To improve performance, specify in the list only the attributes that you want returned. If no list is provided, the default action is to return all attributes.
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// MemberAttributes The list of group attributes that are passed in as comma separated values that are used when passing the result back to the caller. For example, the ID and displayName attributes.
	MemberAttributes *string `form:"memberAttributes,omitempty" json:"memberAttributes,omitempty"`

	// MemberCount Specifies the maximum number of query results per page. A negative value is interpreted as 0.  A value of 0 indicates that no member resource results are to be returned, except for totalResults.
	MemberCount *string `form:"memberCount,omitempty" json:"memberCount,omitempty"`

	// MemberStartIndex The starting index of the search.
	MemberStartIndex *string `form:"memberStartIndex,omitempty" json:"memberStartIndex,omitempty"`
}

// PatchUserParams defines parameters for PatchUser.
type PatchUserParams struct {
	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`

	// Usershouldnotneedtoresetpassword If set to true for a password change, the user is not required to change the password after login.
	Usershouldnotneedtoresetpassword *PatchUserParamsUsershouldnotneedtoresetpassword `json:"usershouldnotneedtoresetpassword,omitempty"`
}

// PatchUserParamsUsershouldnotneedtoresetpassword defines parameters for PatchUser.
type PatchUserParamsUsershouldnotneedtoresetpassword string

// PutUser0Params defines parameters for PutUser0.
type PutUser0Params struct {
	// Hashed The comma separated list of attributes whose values are to be hashed.
	Hashed *string `form:"hashed,omitempty" json:"hashed,omitempty"`

	// ThemeID The identifier of the theme that you want to apply.
	ThemeID *string `form:"themeId,omitempty" json:"themeId,omitempty"`

	// Usershouldnotneedtoresetpassword If set to true for a password change, the user is not required to change the password after login.<br>Only honored when the password element of UserV2 is set.
	Usershouldnotneedtoresetpassword *PutUser0ParamsUsershouldnotneedtoresetpassword `json:"usershouldnotneedtoresetpassword,omitempty"`
}

// PutUser0ParamsUsershouldnotneedtoresetpassword defines parameters for PutUser0.
type PutUser0ParamsUsershouldnotneedtoresetpassword string

// GetInstancesV2Params defines parameters for GetInstancesV2.
type GetInstancesV2Params struct {
	// Filter You can use following filters to fetch the identity source instances with specific properties. <br><br><b>enduser</b>: Returns all the identity source instances that are enabled for end users, i.e. the instances with <b>show_end_user</b> property value set as <b>true</b>.<br><br><b>appscope</b>: Returns all the social identity sources, excluding the IBMid identity source, that are associated with custom applications.<br>    Regardless of this filter, Cloud Directory is included as the default provider.
	Filter *GetInstancesV2ParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Search The prefix for all search operations is <b>search=</b>. <br>You can search on following fields: id, sourceTypeId, instanceName, enabled<br>Specifying any other field than the allowed search fields in the criteria will result in an error.<br><br>Valid operators for strings are =, != and contains <br>Valid operators for booleans are = and !=<br>Valid operators for numbers are =, !=, >=, >, &lt=, and &lt<br>String search values must be double quoted; the numbers and booleans must be without quotes. More than one search criteria can be specified using <b>"and"</b> and <b>"or"</b> operators.<br><br>The search parameter value <b>MUST</b> be URL encoded.<br><b>Notes:</b> Only value should be encoded; not the parameter name. Encoding is not required when using Swagger UI.<br><br><b>Examples:</b><br>a. To search on instanceName, provide the search criteria as follows: <br><pre>   instanceName = "Baidu" </pre><br>or in URL encoded form as follows: <br><pre>   search=instanceName%20%3D%20%22Baidu%22 </pre><br>b. To search on instanceName containing "SAML" in it, provide the search criteria as follows: <br><pre>   instanceName contains "SAML" </pre><br>or in URL encoded form as follows: <br><pre>   search=instanceName%20contains%20%22SAML%22 </pre><br>c. To search the SAML Enterprise instances that have "ABC" in their names, provide the search criteria as follows: <br><pre>   instanceName contains "ABC" and sourceTypeId = 4 </pre><br>or in URL encoded form as follows: <br><pre>   search=instanceName%20contains%20%22ABC%22%20and%20sourceTypeId%20%3D%204 </pre><br>
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Pagination The prefix for the paging parameter is <b>pagination=</b>. <br><br>If pagination parameters are not specified, then all the results will be returned. <br><br>If pagination parameters are specified, then the results will be paginated. Following are the parameters that can be specified; these parameters will be included in the response reflecting the actual results. <br><br><b>page</b>: The page being requested, or the offset that defines the starting resource number. <br><b>limit</b>: It is a page size; it defines the total number of resources that can be included in one page. It is the maximum number of resources that will be returned in the response.<b>count</b>: The total number of resources to be returned in the response. It is an optional parameter, and it MUST be less than or equal to the limit. If not specified, then count = limit.<br><br><br>The pagination parameter value <b>MUST</b> be URL encoded.<br><b>Note:</b> Only value should be encoded; not the parameter name. Encoding is not required when using Swagger UI.<br><br><b>Note:</b> The maximum value allowed for the <b>limit</b> or <b>count</b> fields is 1000. <br><br><b>Examples:</b><br>a. To retrieve first 5 or less resources from page 1, provide pagination parameters as follows: <br><pre>   count=5&page=1&limit=10 </pre><br>or in URL encoded form as follows: <br><pre>   pagination=count%3D5%26page%3D1%26limit%3D10 </pre><br>b. To retrieve first 3 or less resources from page 2, provide pagination parameters as follows: <br><pre>   count=3&page=2&limit=10 </pre><br>or in URL encoded form as follows: <br><pre>   pagination=count%3D3%26page%3D2%26limit%3D10 </pre><br>
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Sort The prefix for the sort parameter is <b>sort=</b>. <br>You can sort on following fields: id, sourceTypeId, instanceName, enabled<br>Specifying any other field than the allowed sort fields will result in an error.<br><br>Each sort attribute must be prefixed with either + or - (+ ascending, - descending). A list of attributes separated by a comma (,) can be specified for the second or third order of sorting. <br><br>The sort parameter value <b>MUST</b> be URL encoded.<br><b>Note:</b> Only value should be encoded; not the parameter name. Encoding is not required when using Swagger UI.<br><br><b>Examples:</b><br>a. To sort on sourceTypeId in ascending order, provide the sort parameter as follows: <br><pre>   +sourceTypeId </pre><br>or in URL encoded form as follows: <br><pre>   sort=%2BsourceTypeId </pre><br>b. To sort on sourceTypeId in ascending order and for second order sort on instanceName in descending order, provide the sort parameter as follows: <br><pre>   +sourceTypeId,-instanceName </pre><br>or in URL encoded form as follows: <br><pre>   sort=%2BsourceTypeId%2C-instanceName </pre><br>
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Count The prefix for the count parameter is <b>count=</b>.
	Count *string `form:"count,omitempty" json:"count,omitempty"`
}

// GetInstancesV2ParamsFilter defines parameters for GetInstancesV2.
type GetInstancesV2ParamsFilter string

// ListAccessPoliciesParams defines parameters for ListAccessPolicies.
type ListAccessPoliciesParams struct {
	// Pagination Controls the results that are returned in a page.<br><br>You can use the following query parameters:<br><br><b>count</b> - Optional. Use to define the total number of results that are returned from the data store. The maximum allowed value is 1000. If excluded will be set to limit.<br><br><b>page</b> - Use to identify the requested page, or the offset.<br><br><b>limit</b> - Use to define the total number of results that are returned per page. The maximum allowed value is 1000.<br><br>A maximum of 200 results are returned if no pagination query parameters are passed.<br><br><b>Note</b>: The pagination parameter value must be HTML encoded. Use the prefix "pagination=" in the query parameter.<br><br><b>Example</b>: Paginate on count=10&page=1&limit=5<br>pagination=count%3D10%26page%3D1%26limit%3D5
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Search Returns results based on the search criteria.<br><br>Valid operators for Strings are = , != and contains. Use double quotation marks for the search values.<br>Valid operators for Booleans are = and !=<br>Valid operators for Numbers are >=, >, &lt;=, &lt;, = and !=<br><br><b>Note</b>: The search parameter value must be HTML encoded. Use the prefix "search=" in the query parameter.<br><br><b>Example</b>: Search on id contains "fd45"&enabled=true<br>search=id%20contains%20%22fd45%22%26enabled%3Dtrue
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Filter Displays results based on the filter criteria.<br><br>Filter values to be inclusive or exclusive only. It cannot be combined.<br><br>Use a comma (,) to separate multiple filter parameters.<br><br><b>Note</b>: The filter parameter value must be HTML encoded. Use the prefix "filter=" in the query parameter.<br><br><b>Examples</b><br>Filter to return only id : filter=id<br>Filter to exclude id and enabled : filter=%21id,enabled
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// PostOauth2TokenFormdataRequestBody defines body for PostOauth2Token for application/x-www-form-urlencoded ContentType.
type PostOauth2TokenFormdataRequestBody = TokenRequest

// BulkDeleteAPIClientJSONRequestBody defines body for BulkDeleteAPIClient for application/json ContentType.
type BulkDeleteAPIClientJSONRequestBody = BulkDeleteAPIClientJSONBody

// CreateAPIClientJSONRequestBody defines body for CreateAPIClient for application/json ContentType.
type CreateAPIClientJSONRequestBody = APIClientConfigRequest

// UpdateAPIClientJSONRequestBody defines body for UpdateAPIClient for application/json ContentType.
type UpdateAPIClientJSONRequestBody = APIClientConfig

// RegisterThemeTemplatesMultipartRequestBody defines body for RegisterThemeTemplates for multipart/form-data ContentType.
type RegisterThemeTemplatesMultipartRequestBody RegisterThemeTemplatesMultipartBody

// UpdateThemeTemplatesMultipartRequestBody defines body for UpdateThemeTemplates for multipart/form-data ContentType.
type UpdateThemeTemplatesMultipartRequestBody UpdateThemeTemplatesMultipartBody

// UpdateThemeTemplateMultipartRequestBody defines body for UpdateThemeTemplate for multipart/form-data ContentType.
type UpdateThemeTemplateMultipartRequestBody UpdateThemeTemplateMultipartBody

// CreateGroupApplicationScimPlusJSONRequestBody defines body for CreateGroup for application/scim+json ContentType.
type CreateGroupApplicationScimPlusJSONRequestBody = GroupV2

// PatchGroupApplicationScimPlusJSONRequestBody defines body for PatchGroup for application/scim+json ContentType.
type PatchGroupApplicationScimPlusJSONRequestBody = PatchBody

// PutGroupApplicationScimPlusJSONRequestBody defines body for PutGroup for application/scim+json ContentType.
type PutGroupApplicationScimPlusJSONRequestBody = GroupV2

// CreateUserApplicationScimPlusJSONRequestBody defines body for CreateUser for application/scim+json ContentType.
type CreateUserApplicationScimPlusJSONRequestBody = UserV2

// PatchUserApplicationScimPlusJSONRequestBody defines body for PatchUser for application/scim+json ContentType.
type PatchUserApplicationScimPlusJSONRequestBody = PatchBody

// PutUser0ApplicationScimPlusJSONRequestBody defines body for PutUser0 for application/scim+json ContentType.
type PutUser0ApplicationScimPlusJSONRequestBody = UserV2

// CreateIdentitySourceV2JSONRequestBody defines body for CreateIdentitySourceV2 for application/json ContentType.
type CreateIdentitySourceV2JSONRequestBody = IdentitySourceInstancesData

// UpdateIdentitySourceV2JSONRequestBody defines body for UpdateIdentitySourceV2 for application/json ContentType.
type UpdateIdentitySourceV2JSONRequestBody = IdentitySourceInstancesData

// CreateAccessPolicyJSONRequestBody defines body for CreateAccessPolicy for application/json ContentType.
type CreateAccessPolicyJSONRequestBody = AccessPolicyRequest

// CreateAccessPolicyRevisionJSONRequestBody defines body for CreateAccessPolicyRevision for application/json ContentType.
type CreateAccessPolicyRevisionJSONRequestBody = AccessPolicyRequest

// UpdateAccessPolicyJSONRequestBody defines body for UpdateAccessPolicy for application/json ContentType.
type UpdateAccessPolicyJSONRequestBody = AccessPolicyRequest

// Getter for additional properties for Header. Returns the specified
// element and whether it was found
func (a Header) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Header
func (a *Header) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Header to handle AdditionalProperties
func (a *Header) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Header to handle AdditionalProperties
func (a Header) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	if a.Value != nil {
		object["value"], err = json.Marshal(a.Value)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'value': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostOauth2TokenWithBody request with any body
	PostOauth2TokenWithBody(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOauth2TokenWithFormdataBody(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIClients request
	GetAPIClients(ctx context.Context, params *GetAPIClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkDeleteAPIClientWithBody request with any body
	BulkDeleteAPIClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkDeleteAPIClient(ctx context.Context, body BulkDeleteAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAPIClientWithBody request with any body
	CreateAPIClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAPIClient(ctx context.Context, body CreateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAPIClient request
	DeleteAPIClient(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIClient request
	GetAPIClient(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAPIClientWithBody request with any body
	UpdateAPIClientWithBody(ctx context.Context, clientID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAPIClient(ctx context.Context, clientID string, body UpdateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAttributes request
	GetAllAttributes(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAttributesWithBody request with any body
	PatchAttributesWithBody(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttributeWithBody request with any body
	CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttribute request
	DeleteAttribute(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttribute0 request
	GetAttribute0(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSingleAttributeWithBody request with any body
	PatchSingleAttributeWithBody(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttributeWithBody request with any body
	UpdateAttributeWithBody(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThemeRegistrations request
	GetThemeRegistrations(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterThemeTemplatesWithBody request with any body
	RegisterThemeTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeregisterTheme request
	DeregisterTheme(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadThemeTemplates request
	DownloadThemeTemplates(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThemeTemplatesWithBody request with any body
	UpdateThemeTemplatesWithBody(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSingleThemeFile request
	DeleteSingleThemeFile(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate0 request
	GetTemplate0(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThemeTemplateWithBody request with any body
	UpdateThemeTemplateWithBody(ctx context.Context, themeID string, templatePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroupWithApplicationScimPlusJSONBody(ctx context.Context, params *CreateGroupParams, body CreateGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, id string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, id string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchGroupWithBody request with any body
	PatchGroupWithBody(ctx context.Context, id string, params *PatchGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchGroupWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PatchGroupParams, body PatchGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutGroupWithBody request with any body
	PutGroupWithBody(ctx context.Context, id string, params *PutGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutGroupWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PutGroupParams, body PutGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserWithApplicationScimPlusJSONBody(ctx context.Context, params *CreateUserParams, body CreateUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser0 request
	DeleteUser0(ctx context.Context, id string, params *DeleteUser0Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser0 request
	GetUser0(ctx context.Context, id string, params *GetUser0Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserWithBody request with any body
	PatchUserWithBody(ctx context.Context, id string, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PatchUserParams, body PatchUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutUser0WithBody request with any body
	PutUser0WithBody(ctx context.Context, id string, params *PutUser0Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutUser0WithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PutUser0Params, body PutUser0ApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstancesV2 request
	GetInstancesV2(ctx context.Context, params *GetInstancesV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIdentitySourceV2WithBody request with any body
	CreateIdentitySourceV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIdentitySourceV2(ctx context.Context, body CreateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIdentitySourceV2 request
	DeleteIdentitySourceV2(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceV2 request
	GetInstanceV2(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIdentitySourceV2WithBody request with any body
	UpdateIdentitySourceV2WithBody(ctx context.Context, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIdentitySourceV2(ctx context.Context, instanceID string, body UpdateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccessPolicies request
	ListAccessPolicies(ctx context.Context, params *ListAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessPolicyWithBody request with any body
	CreateAccessPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessPolicy(ctx context.Context, body CreateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessPolicy request
	DeleteAccessPolicy(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessPolicy request
	GetAccessPolicy(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessPolicyRevisionWithBody request with any body
	CreateAccessPolicyRevisionWithBody(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessPolicyRevision(ctx context.Context, policyID int64, body CreateAccessPolicyRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessPolicyWithBody request with any body
	UpdateAccessPolicyWithBody(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessPolicy(ctx context.Context, policyID int64, body UpdateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostOauth2TokenWithBody(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithFormdataBody(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIClients(ctx context.Context, params *GetAPIClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkDeleteAPIClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkDeleteAPIClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkDeleteAPIClient(ctx context.Context, body BulkDeleteAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkDeleteAPIClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIClient(ctx context.Context, body CreateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAPIClient(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIClientRequest(c.Server, clientID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIClient(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIClientRequest(c.Server, clientID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIClientWithBody(ctx context.Context, clientID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIClientRequestWithBody(c.Server, clientID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIClient(ctx context.Context, clientID string, body UpdateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIClientRequest(c.Server, clientID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAttributes(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAttributesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAttributesWithBody(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAttributesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttribute(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttributeRequest(c.Server, attrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttribute0(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttribute0Request(c.Server, attrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSingleAttributeWithBody(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSingleAttributeRequestWithBody(c.Server, attrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributeWithBody(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributeRequestWithBody(c.Server, attrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThemeRegistrations(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThemeRegistrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterThemeTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterThemeTemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeregisterTheme(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeregisterThemeRequest(c.Server, themeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadThemeTemplates(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadThemeTemplatesRequest(c.Server, themeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThemeTemplatesWithBody(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThemeTemplatesRequestWithBody(c.Server, themeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSingleThemeFile(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSingleThemeFileRequest(c.Server, themeID, templatePath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate0(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplate0Request(c.Server, themeID, templatePath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThemeTemplateWithBody(ctx context.Context, themeID string, templatePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThemeTemplateRequestWithBody(c.Server, themeID, templatePath, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithApplicationScimPlusJSONBody(ctx context.Context, params *CreateGroupParams, body CreateGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithApplicationScimPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, id string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, id string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupWithBody(ctx context.Context, id string, params *PatchGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PatchGroupParams, body PatchGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupRequestWithApplicationScimPlusJSONBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupWithBody(ctx context.Context, id string, params *PutGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PutGroupParams, body PutGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupRequestWithApplicationScimPlusJSONBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithApplicationScimPlusJSONBody(ctx context.Context, params *CreateUserParams, body CreateUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithApplicationScimPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser0(ctx context.Context, id string, params *DeleteUser0Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUser0Request(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser0(ctx context.Context, id string, params *GetUser0Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUser0Request(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, id string, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PatchUserParams, body PatchUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithApplicationScimPlusJSONBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutUser0WithBody(ctx context.Context, id string, params *PutUser0Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUser0RequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutUser0WithApplicationScimPlusJSONBody(ctx context.Context, id string, params *PutUser0Params, body PutUser0ApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUser0RequestWithApplicationScimPlusJSONBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstancesV2(ctx context.Context, params *GetInstancesV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstancesV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIdentitySourceV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIdentitySourceV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIdentitySourceV2(ctx context.Context, body CreateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIdentitySourceV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIdentitySourceV2(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIdentitySourceV2Request(c.Server, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceV2(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceV2Request(c.Server, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIdentitySourceV2WithBody(ctx context.Context, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIdentitySourceV2RequestWithBody(c.Server, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIdentitySourceV2(ctx context.Context, instanceID string, body UpdateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIdentitySourceV2Request(c.Server, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccessPolicies(ctx context.Context, params *ListAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessPolicy(ctx context.Context, body CreateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessPolicy(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessPolicyRequest(c.Server, policyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessPolicy(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessPolicyRequest(c.Server, policyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessPolicyRevisionWithBody(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessPolicyRevisionRequestWithBody(c.Server, policyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessPolicyRevision(ctx context.Context, policyID int64, body CreateAccessPolicyRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessPolicyRevisionRequest(c.Server, policyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessPolicyWithBody(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessPolicyRequestWithBody(c.Server, policyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessPolicy(ctx context.Context, policyID int64, body UpdateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessPolicyRequest(c.Server, policyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostOauth2TokenRequestWithFormdataBody calls the generic PostOauth2Token builder with application/x-www-form-urlencoded body
func NewPostOauth2TokenRequestWithFormdataBody(server string, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOauth2TokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOauth2TokenRequestWithBody generates requests for PostOauth2Token with any type of body
func NewPostOauth2TokenRequestWithBody(server string, params *PostOauth2TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetAPIClientsRequest generates requests for GetAPIClients
func NewGetAPIClientsRequest(server string, params *GetAPIClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkDeleteAPIClientRequest calls the generic BulkDeleteAPIClient builder with application/json body
func NewBulkDeleteAPIClientRequest(server string, body BulkDeleteAPIClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkDeleteAPIClientRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkDeleteAPIClientRequestWithBody generates requests for BulkDeleteAPIClient with any type of body
func NewBulkDeleteAPIClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAPIClientRequest calls the generic CreateAPIClient builder with application/json body
func NewCreateAPIClientRequest(server string, body CreateAPIClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAPIClientRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAPIClientRequestWithBody generates requests for CreateAPIClient with any type of body
func NewCreateAPIClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAPIClientRequest generates requests for DeleteAPIClient
func NewDeleteAPIClientRequest(server string, clientID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIClientRequest generates requests for GetAPIClient
func NewGetAPIClientRequest(server string, clientID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAPIClientRequest calls the generic UpdateAPIClient builder with application/json body
func NewUpdateAPIClientRequest(server string, clientID string, body UpdateAPIClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAPIClientRequestWithBody(server, clientID, "application/json", bodyReader)
}

// NewUpdateAPIClientRequestWithBody generates requests for UpdateAPIClient with any type of body
func NewUpdateAPIClientRequestWithBody(server string, clientID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/apiclients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAttributesRequest generates requests for GetAllAttributes
func NewGetAllAttributesRequest(server string, params *GetAllAttributesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewPatchAttributesRequestWithBody generates requests for PatchAttributes with any type of body
func NewPatchAttributesRequestWithBody(server string, params *PatchAttributesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewCreateAttributeRequestWithBody generates requests for CreateAttribute with any type of body
func NewCreateAttributeRequestWithBody(server string, params *CreateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDeleteAttributeRequest generates requests for DeleteAttribute
func NewDeleteAttributeRequest(server string, attrID string, params *DeleteAttributeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetAttribute0Request generates requests for GetAttribute0
func NewGetAttribute0Request(server string, attrID string, params *GetAttribute0Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewPatchSingleAttributeRequestWithBody generates requests for PatchSingleAttribute with any type of body
func NewPatchSingleAttributeRequestWithBody(server string, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewUpdateAttributeRequestWithBody generates requests for UpdateAttribute with any type of body
func NewUpdateAttributeRequestWithBody(server string, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetThemeRegistrationsRequest generates requests for GetThemeRegistrations
func NewGetThemeRegistrationsRequest(server string, params *GetThemeRegistrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterThemeTemplatesRequestWithBody generates requests for RegisterThemeTemplates with any type of body
func NewRegisterThemeTemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeregisterThemeRequest generates requests for DeregisterTheme
func NewDeregisterThemeRequest(server string, themeID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadThemeTemplatesRequest generates requests for DownloadThemeTemplates
func NewDownloadThemeTemplatesRequest(server string, themeID string, params *DownloadThemeTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomizedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customized_only", runtime.ParamLocationQuery, *params.CustomizedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateThemeTemplatesRequestWithBody generates requests for UpdateThemeTemplates with any type of body
func NewUpdateThemeTemplatesRequestWithBody(server string, themeID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSingleThemeFileRequest generates requests for DeleteSingleThemeFile
func NewDeleteSingleThemeFileRequest(server string, themeID string, templatePath string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "templatePath", runtime.ParamLocationPath, templatePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplate0Request generates requests for GetTemplate0
func NewGetTemplate0Request(server string, themeID string, templatePath string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "templatePath", runtime.ParamLocationPath, templatePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateThemeTemplateRequestWithBody generates requests for UpdateThemeTemplate with any type of body
func NewUpdateThemeTemplateRequestWithBody(server string, themeID string, templatePath string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "templatePath", runtime.ParamLocationPath, templatePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fullText", runtime.ParamLocationQuery, *params.FullText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequestWithApplicationScimPlusJSONBody calls the generic CreateGroup builder with application/scim+json body
func NewCreateGroupRequestWithApplicationScimPlusJSONBody(server string, params *CreateGroupParams, body CreateGroupApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, params, "application/scim+json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, params *CreateGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, id string, params *DeleteGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NotifyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notifyType", runtime.ParamLocationQuery, *params.NotifyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, id string, params *GetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MembershipType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "membershipType", runtime.ParamLocationQuery, *params.MembershipType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberAttributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberAttributes", runtime.ParamLocationQuery, *params.MemberAttributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberCount", runtime.ParamLocationQuery, *params.MemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberStartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberStartIndex", runtime.ParamLocationQuery, *params.MemberStartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPage", runtime.ParamLocationQuery, *params.NextPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchGroupRequestWithApplicationScimPlusJSONBody calls the generic PatchGroup builder with application/scim+json body
func NewPatchGroupRequestWithApplicationScimPlusJSONBody(server string, id string, params *PatchGroupParams, body PatchGroupApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchGroupRequestWithBody(server, id, params, "application/scim+json", bodyReader)
}

// NewPatchGroupRequestWithBody generates requests for PatchGroup with any type of body
func NewPatchGroupRequestWithBody(server string, id string, params *PatchGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutGroupRequestWithApplicationScimPlusJSONBody calls the generic PutGroup builder with application/scim+json body
func NewPutGroupRequestWithApplicationScimPlusJSONBody(server string, id string, params *PutGroupParams, body PutGroupApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutGroupRequestWithBody(server, id, params, "application/scim+json", bodyReader)
}

// NewPutGroupRequestWithBody generates requests for PutGroup with any type of body
func NewPutGroupRequestWithBody(server string, id string, params *PutGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hashed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashed", runtime.ParamLocationQuery, *params.Hashed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fullText", runtime.ParamLocationQuery, *params.FullText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeGroups", runtime.ParamLocationQuery, *params.IncludeGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequestWithApplicationScimPlusJSONBody calls the generic CreateUser builder with application/scim+json body
func NewCreateUserRequestWithApplicationScimPlusJSONBody(server string, params *CreateUserParams, body CreateUserApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/scim+json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hashed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashed", runtime.ParamLocationQuery, *params.Hashed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Usershouldnotneedtoresetpassword != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "usershouldnotneedtoresetpassword", runtime.ParamLocationHeader, *params.Usershouldnotneedtoresetpassword)
			if err != nil {
				return nil, err
			}

			req.Header.Set("usershouldnotneedtoresetpassword", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUser0Request generates requests for DeleteUser0
func NewDeleteUser0Request(server string, id string, params *DeleteUser0Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NotifyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notifyType", runtime.ParamLocationQuery, *params.NotifyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUser0Request generates requests for GetUser0
func NewGetUser0Request(server string, id string, params *GetUser0Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberAttributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberAttributes", runtime.ParamLocationQuery, *params.MemberAttributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberCount", runtime.ParamLocationQuery, *params.MemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberStartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberStartIndex", runtime.ParamLocationQuery, *params.MemberStartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserRequestWithApplicationScimPlusJSONBody calls the generic PatchUser builder with application/scim+json body
func NewPatchUserRequestWithApplicationScimPlusJSONBody(server string, id string, params *PatchUserParams, body PatchUserApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, id, params, "application/scim+json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, id string, params *PatchUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Usershouldnotneedtoresetpassword != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "usershouldnotneedtoresetpassword", runtime.ParamLocationHeader, *params.Usershouldnotneedtoresetpassword)
			if err != nil {
				return nil, err
			}

			req.Header.Set("usershouldnotneedtoresetpassword", headerParam0)
		}

	}

	return req, nil
}

// NewPutUser0RequestWithApplicationScimPlusJSONBody calls the generic PutUser0 builder with application/scim+json body
func NewPutUser0RequestWithApplicationScimPlusJSONBody(server string, id string, params *PutUser0Params, body PutUser0ApplicationScimPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutUser0RequestWithBody(server, id, params, "application/scim+json", bodyReader)
}

// NewPutUser0RequestWithBody generates requests for PutUser0 with any type of body
func NewPutUser0RequestWithBody(server string, id string, params *PutUser0Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hashed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashed", runtime.ParamLocationQuery, *params.Hashed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThemeID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "themeId", runtime.ParamLocationQuery, *params.ThemeID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Usershouldnotneedtoresetpassword != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "usershouldnotneedtoresetpassword", runtime.ParamLocationHeader, *params.Usershouldnotneedtoresetpassword)
			if err != nil {
				return nil, err
			}

			req.Header.Set("usershouldnotneedtoresetpassword", headerParam0)
		}

	}

	return req, nil
}

// NewGetInstancesV2Request generates requests for GetInstancesV2
func NewGetInstancesV2Request(server string, params *GetInstancesV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/identitysources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIdentitySourceV2Request calls the generic CreateIdentitySourceV2 builder with application/json body
func NewCreateIdentitySourceV2Request(server string, body CreateIdentitySourceV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIdentitySourceV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIdentitySourceV2RequestWithBody generates requests for CreateIdentitySourceV2 with any type of body
func NewCreateIdentitySourceV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/identitysources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIdentitySourceV2Request generates requests for DeleteIdentitySourceV2
func NewDeleteIdentitySourceV2Request(server string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/identitysources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceV2Request generates requests for GetInstanceV2
func NewGetInstanceV2Request(server string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/identitysources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIdentitySourceV2Request calls the generic UpdateIdentitySourceV2 builder with application/json body
func NewUpdateIdentitySourceV2Request(server string, instanceID string, body UpdateIdentitySourceV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIdentitySourceV2RequestWithBody(server, instanceID, "application/json", bodyReader)
}

// NewUpdateIdentitySourceV2RequestWithBody generates requests for UpdateIdentitySourceV2 with any type of body
func NewUpdateIdentitySourceV2RequestWithBody(server string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2.0/identitysources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAccessPoliciesRequest generates requests for ListAccessPolicies
func NewListAccessPoliciesRequest(server string, params *ListAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessPolicyRequest calls the generic CreateAccessPolicy builder with application/json body
func NewCreateAccessPolicyRequest(server string, body CreateAccessPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessPolicyRequestWithBody generates requests for CreateAccessPolicy with any type of body
func NewCreateAccessPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessPolicyRequest generates requests for DeleteAccessPolicy
func NewDeleteAccessPolicyRequest(server string, policyID int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessPolicyRequest generates requests for GetAccessPolicy
func NewGetAccessPolicyRequest(server string, policyID int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessPolicyRevisionRequest calls the generic CreateAccessPolicyRevision builder with application/json body
func NewCreateAccessPolicyRevisionRequest(server string, policyID int64, body CreateAccessPolicyRevisionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessPolicyRevisionRequestWithBody(server, policyID, "application/json", bodyReader)
}

// NewCreateAccessPolicyRevisionRequestWithBody generates requests for CreateAccessPolicyRevision with any type of body
func NewCreateAccessPolicyRevisionRequestWithBody(server string, policyID int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAccessPolicyRequest calls the generic UpdateAccessPolicy builder with application/json body
func NewUpdateAccessPolicyRequest(server string, policyID int64, body UpdateAccessPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessPolicyRequestWithBody(server, policyID, "application/json", bodyReader)
}

// NewUpdateAccessPolicyRequestWithBody generates requests for UpdateAccessPolicy with any type of body
func NewUpdateAccessPolicyRequestWithBody(server string, policyID int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v5.0/policyvault/accesspolicy/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostOauth2TokenWithBodyWithResponse request with any body
	PostOauth2TokenWithBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error)

	PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error)

	// GetAPIClientsWithResponse request
	GetAPIClientsWithResponse(ctx context.Context, params *GetAPIClientsParams, reqEditors ...RequestEditorFn) (*GetAPIClientsObject, error)

	// BulkDeleteAPIClientWithBodyWithResponse request with any body
	BulkDeleteAPIClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkDeleteAPIClientObject, error)

	BulkDeleteAPIClientWithResponse(ctx context.Context, body BulkDeleteAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkDeleteAPIClientObject, error)

	// CreateAPIClientWithBodyWithResponse request with any body
	CreateAPIClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIClientObject, error)

	CreateAPIClientWithResponse(ctx context.Context, body CreateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIClientObject, error)

	// DeleteAPIClientWithResponse request
	DeleteAPIClientWithResponse(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*DeleteAPIClientObject, error)

	// GetAPIClientWithResponse request
	GetAPIClientWithResponse(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*GetAPIClientObject, error)

	// UpdateAPIClientWithBodyWithResponse request with any body
	UpdateAPIClientWithBodyWithResponse(ctx context.Context, clientID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIClientObject, error)

	UpdateAPIClientWithResponse(ctx context.Context, clientID string, body UpdateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIClientObject, error)

	// GetAllAttributesWithResponse request
	GetAllAttributesWithResponse(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*GetAllAttributesObject, error)

	// PatchAttributesWithBodyWithResponse request with any body
	PatchAttributesWithBodyWithResponse(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAttributesObject, error)

	// CreateAttributeWithBodyWithResponse request with any body
	CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeObject, error)

	// DeleteAttributeWithResponse request
	DeleteAttributeWithResponse(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeObject, error)

	// GetAttribute0WithResponse request
	GetAttribute0WithResponse(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*GetAttribute0Object, error)

	// PatchSingleAttributeWithBodyWithResponse request with any body
	PatchSingleAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSingleAttributeObject, error)

	// UpdateAttributeWithBodyWithResponse request with any body
	UpdateAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeObject, error)

	// GetThemeRegistrationsWithResponse request
	GetThemeRegistrationsWithResponse(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*GetThemeRegistrationsObject, error)

	// RegisterThemeTemplatesWithBodyWithResponse request with any body
	RegisterThemeTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterThemeTemplatesObject, error)

	// DeregisterThemeWithResponse request
	DeregisterThemeWithResponse(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*DeregisterThemeObject, error)

	// DownloadThemeTemplatesWithResponse request
	DownloadThemeTemplatesWithResponse(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*DownloadThemeTemplatesObject, error)

	// UpdateThemeTemplatesWithBodyWithResponse request with any body
	UpdateThemeTemplatesWithBodyWithResponse(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplatesObject, error)

	// DeleteSingleThemeFileWithResponse request
	DeleteSingleThemeFileWithResponse(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*DeleteSingleThemeFileObject, error)

	// GetTemplate0WithResponse request
	GetTemplate0WithResponse(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*GetTemplate0Object, error)

	// UpdateThemeTemplateWithBodyWithResponse request with any body
	UpdateThemeTemplateWithBodyWithResponse(ctx context.Context, themeID string, templatePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplateObject, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsObject, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupObject, error)

	CreateGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupObject, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, id string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupObject, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, id string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupObject, error)

	// PatchGroupWithBodyWithResponse request with any body
	PatchGroupWithBodyWithResponse(ctx context.Context, id string, params *PatchGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupObject, error)

	PatchGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PatchGroupParams, body PatchGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupObject, error)

	// PutGroupWithBodyWithResponse request with any body
	PutGroupWithBodyWithResponse(ctx context.Context, id string, params *PutGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupObject, error)

	PutGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PutGroupParams, body PutGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupObject, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersObject, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserObject, error)

	CreateUserWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserObject, error)

	// DeleteUser0WithResponse request
	DeleteUser0WithResponse(ctx context.Context, id string, params *DeleteUser0Params, reqEditors ...RequestEditorFn) (*DeleteUser0Object, error)

	// GetUser0WithResponse request
	GetUser0WithResponse(ctx context.Context, id string, params *GetUser0Params, reqEditors ...RequestEditorFn) (*GetUser0Object, error)

	// PatchUserWithBodyWithResponse request with any body
	PatchUserWithBodyWithResponse(ctx context.Context, id string, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserObject, error)

	PatchUserWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PatchUserParams, body PatchUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserObject, error)

	// PutUser0WithBodyWithResponse request with any body
	PutUser0WithBodyWithResponse(ctx context.Context, id string, params *PutUser0Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUser0Object, error)

	PutUser0WithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PutUser0Params, body PutUser0ApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUser0Object, error)

	// GetInstancesV2WithResponse request
	GetInstancesV2WithResponse(ctx context.Context, params *GetInstancesV2Params, reqEditors ...RequestEditorFn) (*GetInstancesV2Object, error)

	// CreateIdentitySourceV2WithBodyWithResponse request with any body
	CreateIdentitySourceV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIdentitySourceV2Object, error)

	CreateIdentitySourceV2WithResponse(ctx context.Context, body CreateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIdentitySourceV2Object, error)

	// DeleteIdentitySourceV2WithResponse request
	DeleteIdentitySourceV2WithResponse(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*DeleteIdentitySourceV2Object, error)

	// GetInstanceV2WithResponse request
	GetInstanceV2WithResponse(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*GetInstanceV2Object, error)

	// UpdateIdentitySourceV2WithBodyWithResponse request with any body
	UpdateIdentitySourceV2WithBodyWithResponse(ctx context.Context, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIdentitySourceV2Object, error)

	UpdateIdentitySourceV2WithResponse(ctx context.Context, instanceID string, body UpdateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIdentitySourceV2Object, error)

	// ListAccessPoliciesWithResponse request
	ListAccessPoliciesWithResponse(ctx context.Context, params *ListAccessPoliciesParams, reqEditors ...RequestEditorFn) (*ListAccessPoliciesObject, error)

	// CreateAccessPolicyWithBodyWithResponse request with any body
	CreateAccessPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessPolicyObject, error)

	CreateAccessPolicyWithResponse(ctx context.Context, body CreateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessPolicyObject, error)

	// DeleteAccessPolicyWithResponse request
	DeleteAccessPolicyWithResponse(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*DeleteAccessPolicyObject, error)

	// GetAccessPolicyWithResponse request
	GetAccessPolicyWithResponse(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*GetAccessPolicyObject, error)

	// CreateAccessPolicyRevisionWithBodyWithResponse request with any body
	CreateAccessPolicyRevisionWithBodyWithResponse(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessPolicyRevisionObject, error)

	CreateAccessPolicyRevisionWithResponse(ctx context.Context, policyID int64, body CreateAccessPolicyRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessPolicyRevisionObject, error)

	// UpdateAccessPolicyWithBodyWithResponse request with any body
	UpdateAccessPolicyWithBodyWithResponse(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessPolicyObject, error)

	UpdateAccessPolicyWithResponse(ctx context.Context, policyID int64, body UpdateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessPolicyObject, error)
}

type PostOauth2TokenObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *Error0
	JSON500      *Error0
}

// Status returns HTTPResponse.Status
func (r PostOauth2TokenObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOauth2TokenObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIClientsObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *APIClientConfigPaginatedResponseContainer
	JSON400                *ErrorResponse
	JSON500                *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAPIClientsObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIClientsObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkDeleteAPIClientObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *BulkResponse
	JSON400      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BulkDeleteAPIClientObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkDeleteAPIClientObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAPIClientObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAPIClientObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAPIClientObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAPIClientObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAPIClientObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIClientObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIClientObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAPIClientObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIClientObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAPIClientObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAPIClientObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAPIClientObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAttributesObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Attribute0
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r GetAllAttributesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAttributesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAttributesObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *PatchOperationResponse
	JSON400      *PatchOperationResponse
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r PatchAttributesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAttributesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r CreateAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r DeleteAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttribute0Object struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *ErrorBean
	JSON404 *ErrorBean
	JSON500 *ErrorBean
}

// Status returns HTTPResponse.Status
func (r GetAttribute0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttribute0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSingleAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r PatchSingleAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSingleAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r UpdateAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThemeRegistrationsObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThemeRegistrationPaginatedResponseContainer
	JSON400      *TemplateError
	JSON401      *TemplateError
	JSON403      *TemplateError
	JSON404      *TemplateError
	JSON405      *TemplateError
	JSON406      *TemplateError
	JSON415      *TemplateError
	JSON500      *TemplateError
}

// Status returns HTTPResponse.Status
func (r GetThemeRegistrationsObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThemeRegistrationsObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeregisterThemeObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeregisterThemeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeregisterThemeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSingleThemeFileObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSingleThemeFileObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSingleThemeFileObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplate0Object struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *TemplateError
	JSON401      *TemplateError
	JSON403      *TemplateError
	JSON404      *TemplateError
	JSON405      *TemplateError
	JSON406      *TemplateError
	JSON415      *TemplateError
	JSON500      *TemplateError
}

// Status returns HTTPResponse.Status
func (r GetTemplate0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplate0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThemeTemplateObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThemeTemplateObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThemeTemplateObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *GetGroupsResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
	ApplicationScimJSON529 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r GetGroupsObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON201 *GroupResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r CreateGroupObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r DeleteGroupObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *GroupResponseV2
	ApplicationScimJSON207 *LargeGroupResponse
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
	ApplicationScimJSON529 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r GetGroupObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchGroupObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r PatchGroupObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutGroupObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *GroupResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r PutGroupObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutGroupObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *GetUsersResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
	ApplicationScimJSON529 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r GetUsersObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON201 *UserResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r CreateUserObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUser0Object struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r DeleteUser0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUser0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUser0Object struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *UserResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
	ApplicationScimJSON529 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r GetUser0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUser0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserObject struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r PatchUserObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutUser0Object struct {
	Body                   []byte
	HTTPResponse           *http.Response
	ApplicationScimJSON200 *UserResponseV2
	ApplicationScimJSON400 *ExternalErrorMessage1
	ApplicationScimJSON403 *ExternalErrorMessage1
	ApplicationScimJSON404 *ExternalErrorMessage1
	ApplicationScimJSON409 *ExternalErrorMessage1
	ApplicationScimJSON500 *ExternalErrorMessage1
}

// Status returns HTTPResponse.Status
func (r PutUser0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutUser0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstancesV2Object struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentitySourceIntancesDataList
	JSON400      *BadRequest0
	JSON403      *Forbidden0
	JSON404      *NotFound0
}

// Status returns HTTPResponse.Status
func (r GetInstancesV2Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstancesV2Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIdentitySourceV2Object struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateIdentitySourceV2Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIdentitySourceV2Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIdentitySourceV2Object struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIdentitySourceV2Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIdentitySourceV2Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceV2Object struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentitySourceInstancesData
	JSON403      *Forbidden0
	JSON404      *NotFound0
}

// Status returns HTTPResponse.Status
func (r GetInstanceV2Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceV2Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIdentitySourceV2Object struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateIdentitySourceV2Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIdentitySourceV2Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccessPoliciesObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyVaultList0
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
	JSON404      *NotFound2
}

// Status returns HTTPResponse.Status
func (r ListAccessPoliciesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccessPoliciesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessPolicyObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy0
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
}

// Status returns HTTPResponse.Status
func (r CreateAccessPolicyObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessPolicyObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessPolicyObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
}

// Status returns HTTPResponse.Status
func (r DeleteAccessPolicyObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessPolicyObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessPolicyObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy0
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
	JSON404      *NotFound2
}

// Status returns HTTPResponse.Status
func (r GetAccessPolicyObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessPolicyObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessPolicyRevisionObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy0
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
}

// Status returns HTTPResponse.Status
func (r CreateAccessPolicyRevisionObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessPolicyRevisionObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessPolicyObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy0
	JSON401      *Unauthorized1
	JSON403      *Forbidden3
}

// Status returns HTTPResponse.Status
func (r UpdateAccessPolicyObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessPolicyObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostOauth2TokenWithBodyWithResponse request with arbitrary body returning *PostOauth2TokenObject
func (c *ClientWithResponses) PostOauth2TokenWithBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error) {
	rsp, err := c.PostOauth2TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenObject(rsp)
}

func (c *ClientWithResponses) PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error) {
	rsp, err := c.PostOauth2TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenObject(rsp)
}

// GetAPIClientsWithResponse request returning *GetAPIClientsObject
func (c *ClientWithResponses) GetAPIClientsWithResponse(ctx context.Context, params *GetAPIClientsParams, reqEditors ...RequestEditorFn) (*GetAPIClientsObject, error) {
	rsp, err := c.GetAPIClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIClientsObject(rsp)
}

// BulkDeleteAPIClientWithBodyWithResponse request with arbitrary body returning *BulkDeleteAPIClientObject
func (c *ClientWithResponses) BulkDeleteAPIClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkDeleteAPIClientObject, error) {
	rsp, err := c.BulkDeleteAPIClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkDeleteAPIClientObject(rsp)
}

func (c *ClientWithResponses) BulkDeleteAPIClientWithResponse(ctx context.Context, body BulkDeleteAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkDeleteAPIClientObject, error) {
	rsp, err := c.BulkDeleteAPIClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkDeleteAPIClientObject(rsp)
}

// CreateAPIClientWithBodyWithResponse request with arbitrary body returning *CreateAPIClientObject
func (c *ClientWithResponses) CreateAPIClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIClientObject, error) {
	rsp, err := c.CreateAPIClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIClientObject(rsp)
}

func (c *ClientWithResponses) CreateAPIClientWithResponse(ctx context.Context, body CreateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIClientObject, error) {
	rsp, err := c.CreateAPIClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIClientObject(rsp)
}

// DeleteAPIClientWithResponse request returning *DeleteAPIClientObject
func (c *ClientWithResponses) DeleteAPIClientWithResponse(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*DeleteAPIClientObject, error) {
	rsp, err := c.DeleteAPIClient(ctx, clientID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIClientObject(rsp)
}

// GetAPIClientWithResponse request returning *GetAPIClientObject
func (c *ClientWithResponses) GetAPIClientWithResponse(ctx context.Context, clientID string, reqEditors ...RequestEditorFn) (*GetAPIClientObject, error) {
	rsp, err := c.GetAPIClient(ctx, clientID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIClientObject(rsp)
}

// UpdateAPIClientWithBodyWithResponse request with arbitrary body returning *UpdateAPIClientObject
func (c *ClientWithResponses) UpdateAPIClientWithBodyWithResponse(ctx context.Context, clientID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIClientObject, error) {
	rsp, err := c.UpdateAPIClientWithBody(ctx, clientID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIClientObject(rsp)
}

func (c *ClientWithResponses) UpdateAPIClientWithResponse(ctx context.Context, clientID string, body UpdateAPIClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIClientObject, error) {
	rsp, err := c.UpdateAPIClient(ctx, clientID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIClientObject(rsp)
}

// GetAllAttributesWithResponse request returning *GetAllAttributesObject
func (c *ClientWithResponses) GetAllAttributesWithResponse(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*GetAllAttributesObject, error) {
	rsp, err := c.GetAllAttributes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAttributesObject(rsp)
}

// PatchAttributesWithBodyWithResponse request with arbitrary body returning *PatchAttributesObject
func (c *ClientWithResponses) PatchAttributesWithBodyWithResponse(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAttributesObject, error) {
	rsp, err := c.PatchAttributesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAttributesObject(rsp)
}

// CreateAttributeWithBodyWithResponse request with arbitrary body returning *CreateAttributeObject
func (c *ClientWithResponses) CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeObject, error) {
	rsp, err := c.CreateAttributeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributeObject(rsp)
}

// DeleteAttributeWithResponse request returning *DeleteAttributeObject
func (c *ClientWithResponses) DeleteAttributeWithResponse(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeObject, error) {
	rsp, err := c.DeleteAttribute(ctx, attrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttributeObject(rsp)
}

// GetAttribute0WithResponse request returning *GetAttribute0Object
func (c *ClientWithResponses) GetAttribute0WithResponse(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*GetAttribute0Object, error) {
	rsp, err := c.GetAttribute0(ctx, attrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttribute0Object(rsp)
}

// PatchSingleAttributeWithBodyWithResponse request with arbitrary body returning *PatchSingleAttributeObject
func (c *ClientWithResponses) PatchSingleAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSingleAttributeObject, error) {
	rsp, err := c.PatchSingleAttributeWithBody(ctx, attrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSingleAttributeObject(rsp)
}

// UpdateAttributeWithBodyWithResponse request with arbitrary body returning *UpdateAttributeObject
func (c *ClientWithResponses) UpdateAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeObject, error) {
	rsp, err := c.UpdateAttributeWithBody(ctx, attrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributeObject(rsp)
}

// GetThemeRegistrationsWithResponse request returning *GetThemeRegistrationsObject
func (c *ClientWithResponses) GetThemeRegistrationsWithResponse(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*GetThemeRegistrationsObject, error) {
	rsp, err := c.GetThemeRegistrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThemeRegistrationsObject(rsp)
}

// RegisterThemeTemplatesWithBodyWithResponse request with arbitrary body returning *RegisterThemeTemplatesObject
func (c *ClientWithResponses) RegisterThemeTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterThemeTemplatesObject, error) {
	rsp, err := c.RegisterThemeTemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterThemeTemplatesObject(rsp)
}

// DeregisterThemeWithResponse request returning *DeregisterThemeObject
func (c *ClientWithResponses) DeregisterThemeWithResponse(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*DeregisterThemeObject, error) {
	rsp, err := c.DeregisterTheme(ctx, themeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeregisterThemeObject(rsp)
}

// DownloadThemeTemplatesWithResponse request returning *DownloadThemeTemplatesObject
func (c *ClientWithResponses) DownloadThemeTemplatesWithResponse(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*DownloadThemeTemplatesObject, error) {
	rsp, err := c.DownloadThemeTemplates(ctx, themeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadThemeTemplatesObject(rsp)
}

// UpdateThemeTemplatesWithBodyWithResponse request with arbitrary body returning *UpdateThemeTemplatesObject
func (c *ClientWithResponses) UpdateThemeTemplatesWithBodyWithResponse(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplatesObject, error) {
	rsp, err := c.UpdateThemeTemplatesWithBody(ctx, themeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThemeTemplatesObject(rsp)
}

// DeleteSingleThemeFileWithResponse request returning *DeleteSingleThemeFileObject
func (c *ClientWithResponses) DeleteSingleThemeFileWithResponse(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*DeleteSingleThemeFileObject, error) {
	rsp, err := c.DeleteSingleThemeFile(ctx, themeID, templatePath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSingleThemeFileObject(rsp)
}

// GetTemplate0WithResponse request returning *GetTemplate0Object
func (c *ClientWithResponses) GetTemplate0WithResponse(ctx context.Context, themeID string, templatePath string, reqEditors ...RequestEditorFn) (*GetTemplate0Object, error) {
	rsp, err := c.GetTemplate0(ctx, themeID, templatePath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplate0Object(rsp)
}

// UpdateThemeTemplateWithBodyWithResponse request with arbitrary body returning *UpdateThemeTemplateObject
func (c *ClientWithResponses) UpdateThemeTemplateWithBodyWithResponse(ctx context.Context, themeID string, templatePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplateObject, error) {
	rsp, err := c.UpdateThemeTemplateWithBody(ctx, themeID, templatePath, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThemeTemplateObject(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsObject
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsObject, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsObject(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupObject
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupObject, error) {
	rsp, err := c.CreateGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupObject(rsp)
}

func (c *ClientWithResponses) CreateGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupObject, error) {
	rsp, err := c.CreateGroupWithApplicationScimPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupObject(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupObject
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, id string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupObject, error) {
	rsp, err := c.DeleteGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupObject(rsp)
}

// GetGroupWithResponse request returning *GetGroupObject
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, id string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupObject, error) {
	rsp, err := c.GetGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupObject(rsp)
}

// PatchGroupWithBodyWithResponse request with arbitrary body returning *PatchGroupObject
func (c *ClientWithResponses) PatchGroupWithBodyWithResponse(ctx context.Context, id string, params *PatchGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupObject, error) {
	rsp, err := c.PatchGroupWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupObject(rsp)
}

func (c *ClientWithResponses) PatchGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PatchGroupParams, body PatchGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupObject, error) {
	rsp, err := c.PatchGroupWithApplicationScimPlusJSONBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupObject(rsp)
}

// PutGroupWithBodyWithResponse request with arbitrary body returning *PutGroupObject
func (c *ClientWithResponses) PutGroupWithBodyWithResponse(ctx context.Context, id string, params *PutGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupObject, error) {
	rsp, err := c.PutGroupWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupObject(rsp)
}

func (c *ClientWithResponses) PutGroupWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PutGroupParams, body PutGroupApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupObject, error) {
	rsp, err := c.PutGroupWithApplicationScimPlusJSONBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupObject(rsp)
}

// GetUsersWithResponse request returning *GetUsersObject
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersObject, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersObject(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserObject
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserObject, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserObject(rsp)
}

func (c *ClientWithResponses) CreateUserWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserObject, error) {
	rsp, err := c.CreateUserWithApplicationScimPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserObject(rsp)
}

// DeleteUser0WithResponse request returning *DeleteUser0Object
func (c *ClientWithResponses) DeleteUser0WithResponse(ctx context.Context, id string, params *DeleteUser0Params, reqEditors ...RequestEditorFn) (*DeleteUser0Object, error) {
	rsp, err := c.DeleteUser0(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUser0Object(rsp)
}

// GetUser0WithResponse request returning *GetUser0Object
func (c *ClientWithResponses) GetUser0WithResponse(ctx context.Context, id string, params *GetUser0Params, reqEditors ...RequestEditorFn) (*GetUser0Object, error) {
	rsp, err := c.GetUser0(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUser0Object(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserObject
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, id string, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserObject, error) {
	rsp, err := c.PatchUserWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserObject(rsp)
}

func (c *ClientWithResponses) PatchUserWithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PatchUserParams, body PatchUserApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserObject, error) {
	rsp, err := c.PatchUserWithApplicationScimPlusJSONBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserObject(rsp)
}

// PutUser0WithBodyWithResponse request with arbitrary body returning *PutUser0Object
func (c *ClientWithResponses) PutUser0WithBodyWithResponse(ctx context.Context, id string, params *PutUser0Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUser0Object, error) {
	rsp, err := c.PutUser0WithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUser0Object(rsp)
}

func (c *ClientWithResponses) PutUser0WithApplicationScimPlusJSONBodyWithResponse(ctx context.Context, id string, params *PutUser0Params, body PutUser0ApplicationScimPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUser0Object, error) {
	rsp, err := c.PutUser0WithApplicationScimPlusJSONBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUser0Object(rsp)
}

// GetInstancesV2WithResponse request returning *GetInstancesV2Object
func (c *ClientWithResponses) GetInstancesV2WithResponse(ctx context.Context, params *GetInstancesV2Params, reqEditors ...RequestEditorFn) (*GetInstancesV2Object, error) {
	rsp, err := c.GetInstancesV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstancesV2Object(rsp)
}

// CreateIdentitySourceV2WithBodyWithResponse request with arbitrary body returning *CreateIdentitySourceV2Object
func (c *ClientWithResponses) CreateIdentitySourceV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIdentitySourceV2Object, error) {
	rsp, err := c.CreateIdentitySourceV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIdentitySourceV2Object(rsp)
}

func (c *ClientWithResponses) CreateIdentitySourceV2WithResponse(ctx context.Context, body CreateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIdentitySourceV2Object, error) {
	rsp, err := c.CreateIdentitySourceV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIdentitySourceV2Object(rsp)
}

// DeleteIdentitySourceV2WithResponse request returning *DeleteIdentitySourceV2Object
func (c *ClientWithResponses) DeleteIdentitySourceV2WithResponse(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*DeleteIdentitySourceV2Object, error) {
	rsp, err := c.DeleteIdentitySourceV2(ctx, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIdentitySourceV2Object(rsp)
}

// GetInstanceV2WithResponse request returning *GetInstanceV2Object
func (c *ClientWithResponses) GetInstanceV2WithResponse(ctx context.Context, instanceID string, reqEditors ...RequestEditorFn) (*GetInstanceV2Object, error) {
	rsp, err := c.GetInstanceV2(ctx, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceV2Object(rsp)
}

// UpdateIdentitySourceV2WithBodyWithResponse request with arbitrary body returning *UpdateIdentitySourceV2Object
func (c *ClientWithResponses) UpdateIdentitySourceV2WithBodyWithResponse(ctx context.Context, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIdentitySourceV2Object, error) {
	rsp, err := c.UpdateIdentitySourceV2WithBody(ctx, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIdentitySourceV2Object(rsp)
}

func (c *ClientWithResponses) UpdateIdentitySourceV2WithResponse(ctx context.Context, instanceID string, body UpdateIdentitySourceV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIdentitySourceV2Object, error) {
	rsp, err := c.UpdateIdentitySourceV2(ctx, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIdentitySourceV2Object(rsp)
}

// ListAccessPoliciesWithResponse request returning *ListAccessPoliciesObject
func (c *ClientWithResponses) ListAccessPoliciesWithResponse(ctx context.Context, params *ListAccessPoliciesParams, reqEditors ...RequestEditorFn) (*ListAccessPoliciesObject, error) {
	rsp, err := c.ListAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccessPoliciesObject(rsp)
}

// CreateAccessPolicyWithBodyWithResponse request with arbitrary body returning *CreateAccessPolicyObject
func (c *ClientWithResponses) CreateAccessPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessPolicyObject, error) {
	rsp, err := c.CreateAccessPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessPolicyObject(rsp)
}

func (c *ClientWithResponses) CreateAccessPolicyWithResponse(ctx context.Context, body CreateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessPolicyObject, error) {
	rsp, err := c.CreateAccessPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessPolicyObject(rsp)
}

// DeleteAccessPolicyWithResponse request returning *DeleteAccessPolicyObject
func (c *ClientWithResponses) DeleteAccessPolicyWithResponse(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*DeleteAccessPolicyObject, error) {
	rsp, err := c.DeleteAccessPolicy(ctx, policyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessPolicyObject(rsp)
}

// GetAccessPolicyWithResponse request returning *GetAccessPolicyObject
func (c *ClientWithResponses) GetAccessPolicyWithResponse(ctx context.Context, policyID int64, reqEditors ...RequestEditorFn) (*GetAccessPolicyObject, error) {
	rsp, err := c.GetAccessPolicy(ctx, policyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessPolicyObject(rsp)
}

// CreateAccessPolicyRevisionWithBodyWithResponse request with arbitrary body returning *CreateAccessPolicyRevisionObject
func (c *ClientWithResponses) CreateAccessPolicyRevisionWithBodyWithResponse(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessPolicyRevisionObject, error) {
	rsp, err := c.CreateAccessPolicyRevisionWithBody(ctx, policyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessPolicyRevisionObject(rsp)
}

func (c *ClientWithResponses) CreateAccessPolicyRevisionWithResponse(ctx context.Context, policyID int64, body CreateAccessPolicyRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessPolicyRevisionObject, error) {
	rsp, err := c.CreateAccessPolicyRevision(ctx, policyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessPolicyRevisionObject(rsp)
}

// UpdateAccessPolicyWithBodyWithResponse request with arbitrary body returning *UpdateAccessPolicyObject
func (c *ClientWithResponses) UpdateAccessPolicyWithBodyWithResponse(ctx context.Context, policyID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessPolicyObject, error) {
	rsp, err := c.UpdateAccessPolicyWithBody(ctx, policyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessPolicyObject(rsp)
}

func (c *ClientWithResponses) UpdateAccessPolicyWithResponse(ctx context.Context, policyID int64, body UpdateAccessPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessPolicyObject, error) {
	rsp, err := c.UpdateAccessPolicy(ctx, policyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessPolicyObject(rsp)
}

// ParsePostOauth2TokenObject parses an HTTP response from a PostOauth2TokenWithResponse call
func ParsePostOauth2TokenObject(rsp *http.Response) (*PostOauth2TokenObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOauth2TokenObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAPIClientsObject parses an HTTP response from a GetAPIClientsWithResponse call
func ParseGetAPIClientsObject(rsp *http.Response) (*GetAPIClientsObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIClientsObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIClientConfigPaginatedResponseContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBulkDeleteAPIClientObject parses an HTTP response from a BulkDeleteAPIClientWithResponse call
func ParseBulkDeleteAPIClientObject(rsp *http.Response) (*BulkDeleteAPIClientObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkDeleteAPIClientObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest BulkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAPIClientObject parses an HTTP response from a CreateAPIClientWithResponse call
func ParseCreateAPIClientObject(rsp *http.Response) (*CreateAPIClientObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAPIClientObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAPIClientObject parses an HTTP response from a DeleteAPIClientWithResponse call
func ParseDeleteAPIClientObject(rsp *http.Response) (*DeleteAPIClientObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIClientObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAPIClientObject parses an HTTP response from a GetAPIClientWithResponse call
func ParseGetAPIClientObject(rsp *http.Response) (*GetAPIClientObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIClientObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAPIClientObject parses an HTTP response from a UpdateAPIClientWithResponse call
func ParseUpdateAPIClientObject(rsp *http.Response) (*UpdateAPIClientObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAPIClientObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllAttributesObject parses an HTTP response from a GetAllAttributesWithResponse call
func ParseGetAllAttributesObject(rsp *http.Response) (*GetAllAttributesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAttributesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Attribute0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchAttributesObject parses an HTTP response from a PatchAttributesWithResponse call
func ParsePatchAttributesObject(rsp *http.Response) (*PatchAttributesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAttributesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest PatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAttributeObject parses an HTTP response from a CreateAttributeWithResponse call
func ParseCreateAttributeObject(rsp *http.Response) (*CreateAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAttributeObject parses an HTTP response from a DeleteAttributeWithResponse call
func ParseDeleteAttributeObject(rsp *http.Response) (*DeleteAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttribute0Object parses an HTTP response from a GetAttribute0WithResponse call
func ParseGetAttribute0Object(rsp *http.Response) (*GetAttribute0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttribute0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSingleAttributeObject parses an HTTP response from a PatchSingleAttributeWithResponse call
func ParsePatchSingleAttributeObject(rsp *http.Response) (*PatchSingleAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSingleAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttributeObject parses an HTTP response from a UpdateAttributeWithResponse call
func ParseUpdateAttributeObject(rsp *http.Response) (*UpdateAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThemeRegistrationsObject parses an HTTP response from a GetThemeRegistrationsWithResponse call
func ParseGetThemeRegistrationsObject(rsp *http.Response) (*GetThemeRegistrationsObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThemeRegistrationsObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThemeRegistrationPaginatedResponseContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterThemeTemplatesObject parses an HTTP response from a RegisterThemeTemplatesWithResponse call
func ParseRegisterThemeTemplatesObject(rsp *http.Response) (*RegisterThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeregisterThemeObject parses an HTTP response from a DeregisterThemeWithResponse call
func ParseDeregisterThemeObject(rsp *http.Response) (*DeregisterThemeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeregisterThemeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadThemeTemplatesObject parses an HTTP response from a DownloadThemeTemplatesWithResponse call
func ParseDownloadThemeTemplatesObject(rsp *http.Response) (*DownloadThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThemeTemplatesObject parses an HTTP response from a UpdateThemeTemplatesWithResponse call
func ParseUpdateThemeTemplatesObject(rsp *http.Response) (*UpdateThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSingleThemeFileObject parses an HTTP response from a DeleteSingleThemeFileWithResponse call
func ParseDeleteSingleThemeFileObject(rsp *http.Response) (*DeleteSingleThemeFileObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSingleThemeFileObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTemplate0Object parses an HTTP response from a GetTemplate0WithResponse call
func ParseGetTemplate0Object(rsp *http.Response) (*GetTemplate0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplate0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateThemeTemplateObject parses an HTTP response from a UpdateThemeTemplateWithResponse call
func ParseUpdateThemeTemplateObject(rsp *http.Response) (*UpdateThemeTemplateObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThemeTemplateObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupsObject parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsObject(rsp *http.Response) (*GetGroupsObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGroupsResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 529:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON529 = &dest

	}

	return response, nil
}

// ParseCreateGroupObject parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupObject(rsp *http.Response) (*CreateGroupObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupObject parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupObject(rsp *http.Response) (*DeleteGroupObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupObject parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupObject(rsp *http.Response) (*GetGroupObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest LargeGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 529:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON529 = &dest

	}

	return response, nil
}

// ParsePatchGroupObject parses an HTTP response from a PatchGroupWithResponse call
func ParsePatchGroupObject(rsp *http.Response) (*PatchGroupObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchGroupObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParsePutGroupObject parses an HTTP response from a PutGroupWithResponse call
func ParsePutGroupObject(rsp *http.Response) (*PutGroupObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutGroupObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersObject parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersObject(rsp *http.Response) (*GetUsersObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUsersResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 529:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON529 = &dest

	}

	return response, nil
}

// ParseCreateUserObject parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserObject(rsp *http.Response) (*CreateUserObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUser0Object parses an HTTP response from a DeleteUser0WithResponse call
func ParseDeleteUser0Object(rsp *http.Response) (*DeleteUser0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUser0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseGetUser0Object parses an HTTP response from a GetUser0WithResponse call
func ParseGetUser0Object(rsp *http.Response) (*GetUser0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUser0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 529:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON529 = &dest

	}

	return response, nil
}

// ParsePatchUserObject parses an HTTP response from a PatchUserWithResponse call
func ParsePatchUserObject(rsp *http.Response) (*PatchUserObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParsePutUser0Object parses an HTTP response from a PutUser0WithResponse call
func ParsePutUser0Object(rsp *http.Response) (*PutUser0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutUser0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ExternalErrorMessage1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationScimJSON500 = &dest

	}

	return response, nil
}

// ParseGetInstancesV2Object parses an HTTP response from a GetInstancesV2WithResponse call
func ParseGetInstancesV2Object(rsp *http.Response) (*GetInstancesV2Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstancesV2Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentitySourceIntancesDataList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateIdentitySourceV2Object parses an HTTP response from a CreateIdentitySourceV2WithResponse call
func ParseCreateIdentitySourceV2Object(rsp *http.Response) (*CreateIdentitySourceV2Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIdentitySourceV2Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteIdentitySourceV2Object parses an HTTP response from a DeleteIdentitySourceV2WithResponse call
func ParseDeleteIdentitySourceV2Object(rsp *http.Response) (*DeleteIdentitySourceV2Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIdentitySourceV2Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInstanceV2Object parses an HTTP response from a GetInstanceV2WithResponse call
func ParseGetInstanceV2Object(rsp *http.Response) (*GetInstanceV2Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceV2Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentitySourceInstancesData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateIdentitySourceV2Object parses an HTTP response from a UpdateIdentitySourceV2WithResponse call
func ParseUpdateIdentitySourceV2Object(rsp *http.Response) (*UpdateIdentitySourceV2Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIdentitySourceV2Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAccessPoliciesObject parses an HTTP response from a ListAccessPoliciesWithResponse call
func ParseListAccessPoliciesObject(rsp *http.Response) (*ListAccessPoliciesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccessPoliciesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyVaultList0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAccessPolicyObject parses an HTTP response from a CreateAccessPolicyWithResponse call
func ParseCreateAccessPolicyObject(rsp *http.Response) (*CreateAccessPolicyObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessPolicyObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAccessPolicyObject parses an HTTP response from a DeleteAccessPolicyWithResponse call
func ParseDeleteAccessPolicyObject(rsp *http.Response) (*DeleteAccessPolicyObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessPolicyObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAccessPolicyObject parses an HTTP response from a GetAccessPolicyWithResponse call
func ParseGetAccessPolicyObject(rsp *http.Response) (*GetAccessPolicyObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessPolicyObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAccessPolicyRevisionObject parses an HTTP response from a CreateAccessPolicyRevisionWithResponse call
func ParseCreateAccessPolicyRevisionObject(rsp *http.Response) (*CreateAccessPolicyRevisionObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessPolicyRevisionObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateAccessPolicyObject parses an HTTP response from a UpdateAccessPolicyWithResponse call
func ParseUpdateAccessPolicyObject(rsp *http.Response) (*UpdateAccessPolicyObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessPolicyObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}
