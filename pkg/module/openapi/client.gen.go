// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AllowBlockListInputOutputAccountStatus.
const (
	AllowBlockListInputOutputAccountStatusCompliant    AllowBlockListInputOutputAccountStatus = "compliant"
	AllowBlockListInputOutputAccountStatusNonCompliant AllowBlockListInputOutputAccountStatus = "non_compliant"
	AllowBlockListInputOutputAccountStatusUnmatched    AllowBlockListInputOutputAccountStatus = "unmatched"
)

// Defines values for Attribute0Datatype.
const (
	Attribute0DatatypeBoolean  Attribute0Datatype = "boolean"
	Attribute0DatatypeInteger  Attribute0Datatype = "integer"
	Attribute0DatatypeInteger1 Attribute0Datatype = "integer[]"
	Attribute0DatatypeString   Attribute0Datatype = "string"
	Attribute0DatatypeString1  Attribute0Datatype = "string[]"
)

// Defines values for Attribute0SourceType.
const (
	Attribute0SourceTypeCredential Attribute0SourceType = "credential"
	Attribute0SourceTypeProfile    Attribute0SourceType = "profile"
	Attribute0SourceTypeSchema     Attribute0SourceType = "schema"
	Attribute0SourceTypeStatic     Attribute0SourceType = "static"
)

// Defines values for CampaignConfigurationOutputLaunchDate.
const (
	CampaignConfigurationOutputLaunchDateEpoch           CampaignConfigurationOutputLaunchDate = "epoch"
	CampaignConfigurationOutputLaunchDateYyyyMMDdTHHMmSs CampaignConfigurationOutputLaunchDate = "yyyy-MM-dd'T'HH:mm:ss"
)

// Defines values for CampaignConfigurationOutputMitigationActionType.
const (
	CampaignConfigurationOutputMitigationActionTypeNone     CampaignConfigurationOutputMitigationActionType = "none"
	CampaignConfigurationOutputMitigationActionTypeReminder CampaignConfigurationOutputMitigationActionType = "reminder"
)

// Defines values for CampaignConfigurationOutputOverdueAction.
const (
	CampaignConfigurationOutputOverdueActionApproveAll CampaignConfigurationOutputOverdueAction = "approveAll"
	CampaignConfigurationOutputOverdueActionDoNothing  CampaignConfigurationOutputOverdueAction = "doNothing"
	CampaignConfigurationOutputOverdueActionRejectAll  CampaignConfigurationOutputOverdueAction = "rejectAll"
)

// Defines values for CampaignConfigurationOutputPriority.
const (
	CampaignConfigurationOutputPriorityAll    CampaignConfigurationOutputPriority = "all"
	CampaignConfigurationOutputPriorityHigh   CampaignConfigurationOutputPriority = "high"
	CampaignConfigurationOutputPriorityLow    CampaignConfigurationOutputPriority = "low"
	CampaignConfigurationOutputPriorityMedium CampaignConfigurationOutputPriority = "medium"
)

// Defines values for CampaignConfigurationOutputSignOff.
const (
	CampaignConfigurationOutputSignOffAuto      CampaignConfigurationOutputSignOff = "auto"
	CampaignConfigurationOutputSignOffEoc       CampaignConfigurationOutputSignOff = "eoc"
	CampaignConfigurationOutputSignOffManual    CampaignConfigurationOutputSignOff = "manual"
	CampaignConfigurationOutputSignOffNoSignoff CampaignConfigurationOutputSignOff = "no_signoff"
)

// Defines values for CampaignConfigurationOutputType.
const (
	CampaignConfigurationOutputTypeAccount         CampaignConfigurationOutputType = "account"
	CampaignConfigurationOutputTypeAll             CampaignConfigurationOutputType = "all"
	CampaignConfigurationOutputTypeGroupassignment CampaignConfigurationOutputType = "groupassignment"
	CampaignConfigurationOutputTypeUserassignment  CampaignConfigurationOutputType = "userassignment"
)

// Defines values for ClientAuthenticationClientAssertionType.
const (
	ClientAuthenticationClientAssertionTypeUrnIetfParamsOauthClientAssertionTypeJwtBearer ClientAuthenticationClientAssertionType = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
)

// Defines values for DatabaseMetaDataRowIDLifetime.
const (
	DatabaseMetaDataRowIDLifetimeROWIDUNSUPPORTED      DatabaseMetaDataRowIDLifetime = "ROWID_UNSUPPORTED"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDFOREVER     DatabaseMetaDataRowIDLifetime = "ROWID_VALID_FOREVER"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDOTHER       DatabaseMetaDataRowIDLifetime = "ROWID_VALID_OTHER"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDSESSION     DatabaseMetaDataRowIDLifetime = "ROWID_VALID_SESSION"
	DatabaseMetaDataRowIDLifetimeROWIDVALIDTRANSACTION DatabaseMetaDataRowIDLifetime = "ROWID_VALID_TRANSACTION"
)

// Defines values for PatchOperationOp.
const (
	PatchOperationOpRemove PatchOperationOp = "remove"
	PatchOperationOpUpdate PatchOperationOp = "update"
)

// Defines values for PatchOperationResultOp.
const (
	PatchOperationResultOpRemove PatchOperationResultOp = "remove"
	PatchOperationResultOpUpdate PatchOperationResultOp = "update"
)

// Defines values for PatchOperationResultResult.
const (
	PatchOperationResultResultFailure PatchOperationResultResult = "failure"
	PatchOperationResultResultSuccess PatchOperationResultResult = "success"
)

// Defines values for PatchSingleAttributeReqModelDatatype.
const (
	PatchSingleAttributeReqModelDatatypeBoolean  PatchSingleAttributeReqModelDatatype = "boolean"
	PatchSingleAttributeReqModelDatatypeInteger  PatchSingleAttributeReqModelDatatype = "integer"
	PatchSingleAttributeReqModelDatatypeInteger1 PatchSingleAttributeReqModelDatatype = "integer[]"
	PatchSingleAttributeReqModelDatatypeString   PatchSingleAttributeReqModelDatatype = "string"
	PatchSingleAttributeReqModelDatatypeString1  PatchSingleAttributeReqModelDatatype = "string[]"
)

// Defines values for PatchSingleAttributeReqModelSourceType.
const (
	PatchSingleAttributeReqModelSourceTypeCredential PatchSingleAttributeReqModelSourceType = "credential"
	PatchSingleAttributeReqModelSourceTypeSchema     PatchSingleAttributeReqModelSourceType = "schema"
	PatchSingleAttributeReqModelSourceTypeStatic     PatchSingleAttributeReqModelSourceType = "static"
)

// Defines values for PlanPackageDeploymentState.
const (
	PlanPackageDeploymentStateARCHIVED         PlanPackageDeploymentState = "ARCHIVED"
	PlanPackageDeploymentStateDEPLOYED         PlanPackageDeploymentState = "DEPLOYED"
	PlanPackageDeploymentStateDEPRECATED       PlanPackageDeploymentState = "DEPRECATED"
	PlanPackageDeploymentStatePENDING          PlanPackageDeploymentState = "PENDING"
	PlanPackageDeploymentStatePUBLISHED        PlanPackageDeploymentState = "PUBLISHED"
	PlanPackageDeploymentStateRETIRED          PlanPackageDeploymentState = "RETIRED"
	PlanPackageDeploymentStateRUNNING          PlanPackageDeploymentState = "RUNNING"
	PlanPackageDeploymentStateSTOPPED          PlanPackageDeploymentState = "STOPPED"
	PlanPackageDeploymentStateSUSPENDED        PlanPackageDeploymentState = "SUSPENDED"
	PlanPackageDeploymentStateTRANSIENTREMOVED PlanPackageDeploymentState = "TRANSIENT_REMOVED"
)

// Defines values for PlanPackageDocumentType.
const (
	PlanPackageDocumentTypeAPIRESOURCE    PlanPackageDocumentType = "APIRESOURCE"
	PlanPackageDocumentTypeAPIVERSION     PlanPackageDocumentType = "APIVERSION"
	PlanPackageDocumentTypePLANVERSION    PlanPackageDocumentType = "PLANVERSION"
	PlanPackageDocumentTypePOLICYTYPE     PlanPackageDocumentType = "POLICYTYPE"
	PlanPackageDocumentTypePRODUCTVERSION PlanPackageDocumentType = "PRODUCTVERSION"
)

// Defines values for PlanPackagePendingDeploymentState.
const (
	PlanPackagePendingDeploymentStateARCHIVE        PlanPackagePendingDeploymentState = "ARCHIVE"
	PlanPackagePendingDeploymentStateDEPRECATE      PlanPackagePendingDeploymentState = "DEPRECATE"
	PlanPackagePendingDeploymentStatePUBLISH        PlanPackagePendingDeploymentState = "PUBLISH"
	PlanPackagePendingDeploymentStateREMOVE         PlanPackagePendingDeploymentState = "REMOVE"
	PlanPackagePendingDeploymentStateREPLACE        PlanPackagePendingDeploymentState = "REPLACE"
	PlanPackagePendingDeploymentStateRESTAGE        PlanPackagePendingDeploymentState = "RESTAGE"
	PlanPackagePendingDeploymentStateRETIRE         PlanPackagePendingDeploymentState = "RETIRE"
	PlanPackagePendingDeploymentStateSTAGEFROMDRAFT PlanPackagePendingDeploymentState = "STAGE_FROM_DRAFT"
	PlanPackagePendingDeploymentStateSUPERSEDE      PlanPackagePendingDeploymentState = "SUPERSEDE"
	PlanPackagePendingDeploymentStateUPDATE         PlanPackagePendingDeploymentState = "UPDATE"
)

// Defines values for ServletContextDefaultSessionTrackingModes.
const (
	ServletContextDefaultSessionTrackingModesCOOKIE ServletContextDefaultSessionTrackingModes = "COOKIE"
	ServletContextDefaultSessionTrackingModesSSL    ServletContextDefaultSessionTrackingModes = "SSL"
	ServletContextDefaultSessionTrackingModesURL    ServletContextDefaultSessionTrackingModes = "URL"
)

// Defines values for ServletContextEffectiveSessionTrackingModes.
const (
	ServletContextEffectiveSessionTrackingModesCOOKIE ServletContextEffectiveSessionTrackingModes = "COOKIE"
	ServletContextEffectiveSessionTrackingModesSSL    ServletContextEffectiveSessionTrackingModes = "SSL"
	ServletContextEffectiveSessionTrackingModesURL    ServletContextEffectiveSessionTrackingModes = "URL"
)

// Defines values for ServletRequestDispatcherType.
const (
	ServletRequestDispatcherTypeASYNC   ServletRequestDispatcherType = "ASYNC"
	ServletRequestDispatcherTypeERROR   ServletRequestDispatcherType = "ERROR"
	ServletRequestDispatcherTypeFORWARD ServletRequestDispatcherType = "FORWARD"
	ServletRequestDispatcherTypeINCLUDE ServletRequestDispatcherType = "INCLUDE"
	ServletRequestDispatcherTypeREQUEST ServletRequestDispatcherType = "REQUEST"
)

// Defines values for SubscribeType.
const (
	SubscribeTypeAuthenticated SubscribeType = "authenticated"
	SubscribeTypeCustom        SubscribeType = "custom"
)

// Defines values for TaskListGetResponseStatus.
const (
	TaskListGetResponseStatusApproved  TaskListGetResponseStatus = "approved"
	TaskListGetResponseStatusCancelled TaskListGetResponseStatus = "cancelled"
	TaskListGetResponseStatusPending   TaskListGetResponseStatus = "pending"
	TaskListGetResponseStatusRejected  TaskListGetResponseStatus = "rejected"
)

// Defines values for TaskListGetResponseTaskType.
const (
	TaskListGetResponseTaskTypePlanDeploymentApproval    TaskListGetResponseTaskType = "planDeploymentApproval"
	TaskListGetResponseTaskTypePlanSubscriptionApproval  TaskListGetResponseTaskType = "planSubscriptionApproval"
	TaskListGetResponseTaskTypeProductDeploymentApproval TaskListGetResponseTaskType = "productDeploymentApproval"
)

// Defines values for TokenRequestClientAssertionType.
const (
	TokenRequestClientAssertionTypeUrnIetfParamsOauthClientAssertionTypeJwtBearer TokenRequestClientAssertionType = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
)

// Defines values for TokenRequestGrantType.
const (
	TokenRequestGrantTypeAuthorizationCode                        TokenRequestGrantType = "authorization_code"
	TokenRequestGrantTypeClientCredentials                        TokenRequestGrantType = "client_credentials"
	TokenRequestGrantTypePassword                                 TokenRequestGrantType = "password"
	TokenRequestGrantTypeRefreshToken                             TokenRequestGrantType = "refresh_token"
	TokenRequestGrantTypeUrnIetfParamsOauthGrantTypeTokenExchange TokenRequestGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for ViewType.
const (
	ViewTypeAuthenticated ViewType = "authenticated"
	ViewTypeCustom        ViewType = "custom"
	ViewTypePublic        ViewType = "public"
)

// AllowBlockListInputOutput Object used to represent an allowlist and blocklist.
type AllowBlockListInputOutput struct {
	// AGroup Specifies if the filter refers to a group. The values are true or false.
	AGroup *bool `json:"aGroup,omitempty"`

	// AccountOwnershipType Account ownership type.
	AccountOwnershipType *string `json:"accountOwnershipType,omitempty"`

	// AccountStatus To filter the account status.
	AccountStatus *AllowBlockListInputOutputAccountStatus `json:"accountStatus,omitempty"`

	// Description Description of group
	Description *string `json:"description,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FamilyName The family name of the user, or the last name in most Western languages. For example, Jensen is the family name from the full name Ms. Barbara J Jensen, PhD.
	FamilyName *string `json:"familyName,omitempty"`

	// Formatted The full name of the user that includes  user name, middle name, and suffix, that are formatted for display.
	Formatted *string `json:"formatted,omitempty"`

	// GivenName The given name of the user, or first name in most Western languages. For example, Barbara is the given name from the full name Ms. Barbara J Jensen, PhD.
	GivenName *string `json:"givenName,omitempty"`

	// ID The user identifier of the user to be filtered.
	ID *string `json:"id,omitempty"`

	// Name The userName or groupName of the user or group.
	Name *string `json:"name,omitempty"`

	// Realm The realm to which the user belongs. It is always "cloudIdentityRealm" for regular users. Maximum length is 240 characters.
	Realm *string `json:"realm,omitempty"`

	// UserType The type of the user. For example, regular, federated.
	UserType *string `json:"userType,omitempty"`
}

// AllowBlockListInputOutputAccountStatus To filter the account status.
type AllowBlockListInputOutputAccountStatus string

// ApplicationV1 defines model for ApplicationV1.
type ApplicationV1 struct {
	Description *string `json:"description,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	ID          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	URL         *string `json:"url,omitempty"`
}

// AsyncContext defines model for AsyncContext.
type AsyncContext struct {
	Request  *ServletRequest  `json:"request,omitempty"`
	Response *ServletResponse `json:"response,omitempty"`
	Timeout  *int64           `json:"timeout,omitempty"`
}

// Attribute0 defines model for Attribute_0.
type Attribute0 struct {
	Constraints *Constraints `json:"constraints,omitempty"`

	// CredName The name of the attribute in the login session credentials. Maximum length is 2048 characters
	CredName *string `json:"credName,omitempty"`

	// CredNameOverrides Realm specific name of the attribute in the login session credentials. This property is specified in the form of key-value pairs where the key is the name of the realm  and the value is the name of the attribute used to override the 'credName' property. Maximum length is 2048 characters
	CredNameOverrides *map[string]string `json:"credNameOverrides,omitempty"`

	// CustomProperties Identifies the attribute custom properties that are attached to this attribute
	CustomProperties *map[string]string `json:"customProperties,omitempty"`

	// Datatype The type of derived data that is expected for the attribute. Defaults to string. The integer datatype is used for any numerical value.
	Datatype Attribute0Datatype `json:"datatype"`

	// Description The description of the attribute. Maximum length is 2048 characters
	Description *string   `json:"description,omitempty"`
	Function    *Function `json:"function,omitempty"`

	// ID The unique identifier for the attribute
	ID *string `json:"id,omitempty"`

	// Name The human-readable name of the attribute. Maximum length is 2048 characters
	Name             string            `json:"name"`
	ProfileAttribute *ProfileAttribute `json:"profileAttribute,omitempty"`
	SchemaAttribute  *SchemaAttribute  `json:"schemaAttribute,omitempty"`

	// Scope Identifies whether the attribute is defined globally by the system or specific to the tenant
	Scope *string `json:"scope,omitempty"`

	// SourceType The type of the attribute source from which the attribute value is derived
	SourceType Attribute0SourceType `json:"sourceType"`

	// Tags The tags used to categorize attributes. Maximum number of tags is 25
	Tags *[]string `json:"tags,omitempty"`

	// Value The default value of the attribute. This value also refers to the fixed value for sourceType="static". Maximum length is 2048 characters
	Value *string `json:"value,omitempty"`
}

// Attribute0Datatype The type of derived data that is expected for the attribute. Defaults to string. The integer datatype is used for any numerical value.
type Attribute0Datatype string

// Attribute0SourceType The type of the attribute source from which the attribute value is derived
type Attribute0SourceType string

// BufferedReader defines model for BufferedReader.
type BufferedReader = map[string]interface{}

// CampaignConfigurationOutput Representation of a campaign configuration for REST APIs
type CampaignConfigurationOutput struct {
	// AllowSupervisorEscalation Allow escalation to the supervisors.
	AllowSupervisorEscalation *bool `json:"allowSupervisorEscalation,omitempty"`

	// Allowlist List of users or groups that are allowed for the certification
	Allowlist    *[]AllowBlockListInputOutput `json:"allowlist,omitempty"`
	Applications *ApplicationV1               `json:"applications,omitempty"`

	// AssociatedPreviewCampaign Representation of a campaign configuration for REST APIs
	AssociatedPreviewCampaign *CampaignConfigurationOutput `json:"associatedPreviewCampaign,omitempty"`

	// AutomaticRefreshContinuousCampaign A flag for a campaign to refresh the existing filter for building dataset. It is valid for continuous campaigns only.
	AutomaticRefreshContinuousCampaign *bool                        `json:"automaticRefreshContinuousCampaign,omitempty"`
	Blacklist                          *[]AllowBlockListInputOutput `json:"blacklist,omitempty"`

	// Blocklist List of users or groups denied for the certification
	Blocklist *[]AllowBlockListInputOutput `json:"blocklist,omitempty"`

	// Continuous A flag for a continuous campaign
	Continuous *bool `json:"continuous,omitempty"`

	// CreationDate Creation date of the campaign configuration
	CreationDate *string `json:"creationDate,omitempty"`

	// DefaultReviewer Represents a user group
	DefaultReviewer *UserGroupV1 `json:"defaultReviewer,omitempty"`

	// Description Campaign description
	Description *string `json:"description,omitempty"`

	// Draft A flag for a draft campaign
	Draft *bool `json:"draft,omitempty"`

	// Duration The duration (in milliseconds) for which each campaign instance remains open
	Duration int64 `json:"duration"`

	// EntitlementFilter Rest representation for an entitlement or entitlement condition set filter.
	EntitlementFilter *EntitlementWithConditionSet `json:"entitlementFilter,omitempty"`

	// Frequency A UNIX or Linux Cron-compatible string that defines the start of subsequent instances
	Frequency *string `json:"frequency,omitempty"`

	// ID Campaign configuration ID
	ID *string `json:"id,omitempty"`

	// IsDeleted The campaign configuration was deleted
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// LaunchDate Date when the first instance of the campaign starts
	LaunchDate CampaignConfigurationOutputLaunchDate `json:"launchDate"`

	// MitigationAction The action to be taken after a while to avoid open records when a campaign closes.
	MitigationAction *struct {
		ReminderInterval *int64                                           `json:"reminderInterval,omitempty"`
		Type             *CampaignConfigurationOutputMitigationActionType `json:"type,omitempty"`
	} `json:"mitigationAction,omitempty"`

	// Name Campaign name
	Name string `json:"name"`

	// NextRunDate Estimated next run date for this configuration, if any
	NextRunDate *string `json:"nextRunDate,omitempty"`

	// OverdueAction The action to be taken for open records when a campaign closes.
	OverdueAction *CampaignConfigurationOutputOverdueAction `json:"overdueAction,omitempty"`

	// Owner Represents a user group
	Owner *UserGroupV1 `json:"owner,omitempty"`

	// Preview A flag for a preview campaign, not opened to reviewers
	Preview *bool `json:"preview,omitempty"`

	// Priority Campaign priority
	Priority CampaignConfigurationOutputPriority `json:"priority"`

	// Rev Campaign configuration review
	Rev *string `json:"rev,omitempty"`

	// Reviewer Represents a user group
	Reviewer *UserGroupV1 `json:"reviewer,omitempty"`

	// RunEvery Frequency unit days or months
	RunEvery *struct {
		CronString *string `json:"cronString,omitempty"`
	} `json:"runEvery,omitempty"`

	// RunNow A flag to start the campaign immediately
	RunNow *bool `json:"runNow,omitempty"`

	// SignOff The campaign sign-off policy
	SignOff *CampaignConfigurationOutputSignOff `json:"signOff,omitempty"`

	// Supervisors The list of supervisors identified for the campaign.
	Supervisors *[]UserGroupV1 `json:"supervisors,omitempty"`

	// TenantCreationLimits A JSON object that indicates the limits for this tenant
	TenantCreationLimits *struct {
		// CurrentActiveCampaignAssignments Number of current active campaign assignments
		CurrentActiveCampaignAssignments *int64 `json:"current_active_campaign_assignments,omitempty"`

		// CurrentActiveCampaignInstances Number of current active campaign instances
		CurrentActiveCampaignInstances *int `json:"current_active_campaign_instances,omitempty"`

		// CurrentTotalCampaignAssignmentsInDB Current total campaign assignments in db
		CurrentTotalCampaignAssignmentsInDB *int64 `json:"current_total_campaign_assignments_in_db,omitempty"`

		// MaxActiveCampaignAssignments Maximum number of active campaign assignments
		MaxActiveCampaignAssignments *int64 `json:"max_active_campaign_assignments,omitempty"`

		// MaxActiveCampaignInstances Maximum number of active campaign instances
		MaxActiveCampaignInstances *int `json:"max_active_campaign_instances,omitempty"`

		// MaxTotalCampaignAssignmentsInDB Total campaign assignments in db
		MaxTotalCampaignAssignmentsInDB *int64 `json:"max_total_campaign_assignments_in_db,omitempty"`
	} `json:"tenantCreationLimits,omitempty"`
	TenantID   *string `json:"tenantId,omitempty"`
	TenantUUID *string `json:"tenantUUID,omitempty"`

	// Type Campaign type
	Type      CampaignConfigurationOutputType `json:"type"`
	Whitelist *[]AllowBlockListInputOutput    `json:"whitelist,omitempty"`
}

// CampaignConfigurationOutputLaunchDate Date when the first instance of the campaign starts
type CampaignConfigurationOutputLaunchDate string

// CampaignConfigurationOutputMitigationActionType defines model for CampaignConfigurationOutput.MitigationAction.Type.
type CampaignConfigurationOutputMitigationActionType string

// CampaignConfigurationOutputOverdueAction The action to be taken for open records when a campaign closes.
type CampaignConfigurationOutputOverdueAction string

// CampaignConfigurationOutputPriority Campaign priority
type CampaignConfigurationOutputPriority string

// CampaignConfigurationOutputSignOff The campaign sign-off policy
type CampaignConfigurationOutputSignOff string

// CampaignConfigurationOutputType Campaign type
type CampaignConfigurationOutputType string

// ClassLoader defines model for ClassLoader.
type ClassLoader struct {
	Parent *ClassLoader `json:"parent,omitempty"`
}

// ClientAuthentication defines model for ClientAuthentication.
type ClientAuthentication struct {
	// ClientAssertion The JWT assertion being used to authenticate the client.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType The format of client assertion.
	ClientAssertionType *ClientAuthenticationClientAssertionType `json:"client_assertion_type,omitempty"`

	// ClientID The OIDC client ID that is required when the basic authorization header is not set.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret The OIDC client secret that is required when the basic authorization header is not set and the client is not a public client.
	ClientSecret *string `json:"client_secret,omitempty"`
}

// ClientAuthenticationClientAssertionType The format of client assertion.
type ClientAuthenticationClientAssertionType string

// ConfigDataObject defines model for ConfigDataObject.
type ConfigDataObject struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	EnvID     *string    `json:"envId,omitempty"`
	ID        *string    `json:"id,omitempty"`
	OrgID     *string    `json:"orgId,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Connection defines model for Connection.
type Connection struct {
	AutoCommit           *bool                   `json:"autoCommit,omitempty"`
	Catalog              *string                 `json:"catalog,omitempty"`
	ClientInfo           *map[string]string      `json:"clientInfo,omitempty"`
	Closed               *bool                   `json:"closed,omitempty"`
	Holdability          *int32                  `json:"holdability,omitempty"`
	MetaData             *DatabaseMetaData       `json:"metaData,omitempty"`
	NetworkTimeout       *int32                  `json:"networkTimeout,omitempty"`
	ReadOnly             *bool                   `json:"readOnly,omitempty"`
	Schema               *string                 `json:"schema,omitempty"`
	TransactionIsolation *int32                  `json:"transactionIsolation,omitempty"`
	TypeMap              *map[string]interface{} `json:"typeMap,omitempty"`
	Warnings             *SQLWarning             `json:"warnings,omitempty"`
}

// Constraints defines model for Constraints.
type Constraints struct {
	Mandatory             *bool            `json:"mandatory,omitempty"`
	ReadAccessForEndUser  *bool            `json:"readAccessForEndUser,omitempty"`
	Unique                *bool            `json:"unique,omitempty"`
	ValueConstraint       *ValueConstraint `json:"valueConstraint,omitempty"`
	ValueConstraintFormat *string          `json:"valueConstraintFormat,omitempty"`
	ValueConstraintType   *string          `json:"valueConstraintType,omitempty"`
	WriteAccessForEndUser *bool            `json:"writeAccessForEndUser,omitempty"`
}

// DatabaseMetaData defines model for DatabaseMetaData.
type DatabaseMetaData struct {
	CatalogAtStart              *bool                          `json:"catalogAtStart,omitempty"`
	CatalogSeparator            *string                        `json:"catalogSeparator,omitempty"`
	CatalogTerm                 *string                        `json:"catalogTerm,omitempty"`
	Catalogs                    *ResultSet                     `json:"catalogs,omitempty"`
	ClientInfoProperties        *ResultSet                     `json:"clientInfoProperties,omitempty"`
	Connection                  *Connection                    `json:"connection,omitempty"`
	DatabaseMajorVersion        *int32                         `json:"databaseMajorVersion,omitempty"`
	DatabaseMinorVersion        *int32                         `json:"databaseMinorVersion,omitempty"`
	DatabaseProductName         *string                        `json:"databaseProductName,omitempty"`
	DatabaseProductVersion      *string                        `json:"databaseProductVersion,omitempty"`
	DefaultTransactionIsolation *int32                         `json:"defaultTransactionIsolation,omitempty"`
	DriverMajorVersion          *int32                         `json:"driverMajorVersion,omitempty"`
	DriverMinorVersion          *int32                         `json:"driverMinorVersion,omitempty"`
	DriverName                  *string                        `json:"driverName,omitempty"`
	DriverVersion               *string                        `json:"driverVersion,omitempty"`
	ExtraNameCharacters         *string                        `json:"extraNameCharacters,omitempty"`
	IdentifierQuoteString       *string                        `json:"identifierQuoteString,omitempty"`
	JdbcmajorVersion            *int32                         `json:"jdbcmajorVersion,omitempty"`
	JdbcminorVersion            *int32                         `json:"jdbcminorVersion,omitempty"`
	MaxBinaryLiteralLength      *int32                         `json:"maxBinaryLiteralLength,omitempty"`
	MaxCatalogNameLength        *int32                         `json:"maxCatalogNameLength,omitempty"`
	MaxCharLiteralLength        *int32                         `json:"maxCharLiteralLength,omitempty"`
	MaxColumnNameLength         *int32                         `json:"maxColumnNameLength,omitempty"`
	MaxColumnsInGroupBy         *int32                         `json:"maxColumnsInGroupBy,omitempty"`
	MaxColumnsInIndex           *int32                         `json:"maxColumnsInIndex,omitempty"`
	MaxColumnsInOrderBy         *int32                         `json:"maxColumnsInOrderBy,omitempty"`
	MaxColumnsInSelect          *int32                         `json:"maxColumnsInSelect,omitempty"`
	MaxColumnsInTable           *int32                         `json:"maxColumnsInTable,omitempty"`
	MaxConnections              *int32                         `json:"maxConnections,omitempty"`
	MaxCursorNameLength         *int32                         `json:"maxCursorNameLength,omitempty"`
	MaxIndexLength              *int32                         `json:"maxIndexLength,omitempty"`
	MaxLogicalLobSize           *int64                         `json:"maxLogicalLobSize,omitempty"`
	MaxProcedureNameLength      *int32                         `json:"maxProcedureNameLength,omitempty"`
	MaxRowSize                  *int32                         `json:"maxRowSize,omitempty"`
	MaxSchemaNameLength         *int32                         `json:"maxSchemaNameLength,omitempty"`
	MaxStatementLength          *int32                         `json:"maxStatementLength,omitempty"`
	MaxStatements               *int32                         `json:"maxStatements,omitempty"`
	MaxTableNameLength          *int32                         `json:"maxTableNameLength,omitempty"`
	MaxTablesInSelect           *int32                         `json:"maxTablesInSelect,omitempty"`
	MaxUserNameLength           *int32                         `json:"maxUserNameLength,omitempty"`
	NumericFunctions            *string                        `json:"numericFunctions,omitempty"`
	ProcedureTerm               *string                        `json:"procedureTerm,omitempty"`
	ReadOnly                    *bool                          `json:"readOnly,omitempty"`
	ResultSetHoldability        *int32                         `json:"resultSetHoldability,omitempty"`
	RowIDLifetime               *DatabaseMetaDataRowIDLifetime `json:"rowIdLifetime,omitempty"`
	SchemaTerm                  *string                        `json:"schemaTerm,omitempty"`
	Schemas                     *ResultSet                     `json:"schemas,omitempty"`
	SearchStringEscape          *string                        `json:"searchStringEscape,omitempty"`
	Sqlkeywords                 *string                        `json:"sqlkeywords,omitempty"`
	SqlstateType                *int32                         `json:"sqlstateType,omitempty"`
	StringFunctions             *string                        `json:"stringFunctions,omitempty"`
	SystemFunctions             *string                        `json:"systemFunctions,omitempty"`
	TableTypes                  *ResultSet                     `json:"tableTypes,omitempty"`
	TimeDateFunctions           *string                        `json:"timeDateFunctions,omitempty"`
	TypeInfo                    *ResultSet                     `json:"typeInfo,omitempty"`
	URL                         *string                        `json:"url,omitempty"`
	UserName                    *string                        `json:"userName,omitempty"`
}

// DatabaseMetaDataRowIDLifetime defines model for DatabaseMetaData.RowIDLifetime.
type DatabaseMetaDataRowIDLifetime string

// DeploymentVisibility defines model for DeploymentVisibility.
type DeploymentVisibility struct {
	Subscribe Subscribe `json:"subscribe"`
	View      View      `json:"view"`
}

// Duration defines model for Duration.
type Duration struct {
	Nano     *int32          `json:"nano,omitempty"`
	Negative *bool           `json:"negative,omitempty"`
	Seconds  *int64          `json:"seconds,omitempty"`
	Units    *[]TemporalUnit `json:"units,omitempty"`
	Zero     *bool           `json:"zero,omitempty"`
}

// EntitlementWithConditionSet Rest representation for an entitlement or entitlement condition set filter.
type EntitlementWithConditionSet struct {
	// EntitlementExclusionList List of Entitlements to be excluded
	EntitlementExclusionList *[]Entitlement0 `json:"entitlementExclusionList,omitempty"`

	// EntitlementInclusionList List of Entitlements to be included
	EntitlementInclusionList *[]Entitlement0 `json:"entitlementInclusionList,omitempty"`
}

// Entitlement0 Rest representation for an entitlement.
type Entitlement0 struct {
	// EntitlementID Unique id of an entitlement
	EntitlementID string `json:"entitlementId"`
}

// EnumerationLocale defines model for EnumerationLocale.
type EnumerationLocale = map[string]interface{}

// EnumerationServlet defines model for EnumerationServlet.
type EnumerationServlet = map[string]interface{}

// EnumerationString defines model for EnumerationString.
type EnumerationString = map[string]interface{}

// ErrorBean defines model for ErrorBean.
type ErrorBean struct {
	// MessageDescription The Locale specific descriptive message
	MessageDescription string `json:"messageDescription"`

	// MessageID The message key identifier
	MessageID string `json:"messageId"`
}

// Error0 defines model for Error_0.
type Error0 struct {
	// Error The OIDC error.
	Error string `json:"error"`

	// ErrorDescription The OIDC error description.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// FederationPartnerV2 defines model for Federation_Partner_V2.
type FederationPartnerV2 struct {
	Configuration *FederationPartnerV2 `json:"configuration,omitempty"`
	Enabled       *bool                `json:"enabled,omitempty"`
	ID            *string              `json:"id,omitempty"`
	Name          *string              `json:"name,omitempty"`
	Role          *string              `json:"role,omitempty"`
	TemplateName  *string              `json:"templateName,omitempty"`
}

// FilterRegistration defines model for FilterRegistration.
type FilterRegistration struct {
	ClassName           *string            `json:"className,omitempty"`
	InitParameters      *map[string]string `json:"initParameters,omitempty"`
	Name                *string            `json:"name,omitempty"`
	ServletNameMappings *[]string          `json:"servletNameMappings,omitempty"`
	URLPatternMappings  *[]string          `json:"urlPatternMappings,omitempty"`
}

// Function defines model for Function.
type Function struct {
	// Custom The custom function
	Custom *string `json:"custom,omitempty"`

	// Name The function name
	Name *string `json:"name,omitempty"`
}

// Header The keys should be in canonical form, as returned by
// CanonicalHeaderKey.
type Header struct {
	Key                  *string             `json:"key,omitempty"`
	Value                *string             `json:"value,omitempty"`
	AdditionalProperties map[string][]string `json:"-"`
}

// JSONArray defines model for JsonArray.
type JSONArray struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	Empty           *bool          `json:"empty,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONNull defines model for JsonNull.
type JSONNull struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONObject defines model for JsonObject.
type JSONObject struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
}

// JSONPrimitive defines model for JsonPrimitive.
type JSONPrimitive struct {
	AsBigDecimal    *float32       `json:"asBigDecimal,omitempty"`
	AsBigInteger    *int           `json:"asBigInteger,omitempty"`
	AsBoolean       *bool          `json:"asBoolean,omitempty"`
	AsByte          *[]byte        `json:"asByte,omitempty"`
	AsCharacter     *string        `json:"asCharacter,omitempty"`
	AsDouble        *float64       `json:"asDouble,omitempty"`
	AsFloat         *float32       `json:"asFloat,omitempty"`
	AsInt           *int32         `json:"asInt,omitempty"`
	AsJSONArray     *JSONArray     `json:"asJsonArray,omitempty"`
	AsJSONNull      *JSONNull      `json:"asJsonNull,omitempty"`
	AsJSONObject    *JSONObject    `json:"asJsonObject,omitempty"`
	AsJSONPrimitive *JSONPrimitive `json:"asJsonPrimitive,omitempty"`
	AsLong          *int64         `json:"asLong,omitempty"`
	AsNumber        *Number        `json:"asNumber,omitempty"`
	AsShort         *int32         `json:"asShort,omitempty"`
	AsString        *string        `json:"asString,omitempty"`
	Boolean         *bool          `json:"boolean,omitempty"`
	JSONArray       *bool          `json:"jsonArray,omitempty"`
	JSONNull        *bool          `json:"jsonNull,omitempty"`
	JSONObject      *bool          `json:"jsonObject,omitempty"`
	JSONPrimitive   *bool          `json:"jsonPrimitive,omitempty"`
	Number          *bool          `json:"number,omitempty"`
	String          *bool          `json:"string,omitempty"`
}

// JspConfigDescriptor defines model for JspConfigDescriptor.
type JspConfigDescriptor struct {
	JspPropertyGroups *[]JspPropertyGroupDescriptor `json:"jspPropertyGroups,omitempty"`
	Taglibs           *[]TaglibDescriptor           `json:"taglibs,omitempty"`
}

// JspPropertyGroupDescriptor defines model for JspPropertyGroupDescriptor.
type JspPropertyGroupDescriptor struct {
	Buffer                         *string   `json:"buffer,omitempty"`
	DefaultContentType             *string   `json:"defaultContentType,omitempty"`
	DeferredSyntaxAllowedAsLiteral *string   `json:"deferredSyntaxAllowedAsLiteral,omitempty"`
	ElIgnored                      *string   `json:"elIgnored,omitempty"`
	ErrorOnUndeclaredNamespace     *string   `json:"errorOnUndeclaredNamespace,omitempty"`
	IncludeCodas                   *[]string `json:"includeCodas,omitempty"`
	IncludePreludes                *[]string `json:"includePreludes,omitempty"`
	IsXML                          *string   `json:"isXml,omitempty"`
	PageEncoding                   *string   `json:"pageEncoding,omitempty"`
	ScriptingInvalid               *string   `json:"scriptingInvalid,omitempty"`
	TrimDirectiveWhitespaces       *string   `json:"trimDirectiveWhitespaces,omitempty"`
	URLPatterns                    *[]string `json:"urlPatterns,omitempty"`
}

// Locale defines model for Locale.
type Locale struct {
	Country                 *string   `json:"country,omitempty"`
	DisplayCountry          *string   `json:"displayCountry,omitempty"`
	DisplayLanguage         *string   `json:"displayLanguage,omitempty"`
	DisplayName             *string   `json:"displayName,omitempty"`
	DisplayScript           *string   `json:"displayScript,omitempty"`
	DisplayVariant          *string   `json:"displayVariant,omitempty"`
	ExtensionKeys           *[]string `json:"extensionKeys,omitempty"`
	Iso3Country             *string   `json:"iso3Country,omitempty"`
	Iso3Language            *string   `json:"iso3Language,omitempty"`
	Language                *string   `json:"language,omitempty"`
	Script                  *string   `json:"script,omitempty"`
	UnicodeLocaleAttributes *[]string `json:"unicodeLocaleAttributes,omitempty"`
	UnicodeLocaleKeys       *[]string `json:"unicodeLocaleKeys,omitempty"`
	Variant                 *string   `json:"variant,omitempty"`
}

// Number defines model for Number.
type Number = map[string]interface{}

// OperationStatusSummary defines model for OperationStatusSummary.
type OperationStatusSummary struct {
	Errors   *[]string            `json:"errors,omitempty"`
	Messages *map[string][]string `json:"messages,omitempty"`
}

// PaginatedAttribute0 defines model for PaginatedAttribute_0.
type PaginatedAttribute0 struct {
	// Attributes list of attributes
	Attributes []Attribute0 `json:"attributes"`
	Count      int          `json:"count"`
	Limit      int          `json:"limit"`
	Page       int          `json:"page"`
	Total      int          `json:"total"`
}

// PatchOperation defines model for PatchOperation.
type PatchOperation struct {
	// Op The patch operation to be executed
	Op PatchOperationOp `json:"op"`

	// Path The attribute id for the patch operation
	Path string `json:"path"`

	// Value The values to update for the resource.<br><br>For global attributes, the following values can be updated using the PATCH API: tags, value, credNameOverrides, function. <br><br>For custom attributes, the following values can be updated using the PATCH API: name, description, sourceType, datatype, tags, value, credName, credNameOverrides, function
	Value *map[string]interface{} `json:"value,omitempty"`
}

// PatchOperationOp The patch operation to be executed
type PatchOperationOp string

// PatchOperationResponse defines model for PatchOperationResponse.
type PatchOperationResponse struct {
	// MessageDescription The error message describing the overall status of the patch operation
	MessageDescription string `json:"messageDescription"`

	// MessageID The error ID describing the overall status of the patch operation
	MessageID string `json:"messageId"`

	// Results The list of execution results for the patch operations requested
	Results []PatchOperationResult `json:"results"`
}

// PatchOperationResult defines model for PatchOperationResult.
type PatchOperationResult struct {
	// Error The error message describing any failures or errors that occurred
	Error *string `json:"error,omitempty"`

	// ErrorID The error ID describing any failures or errors that occurred
	ErrorID *string `json:"errorID,omitempty"`

	// Op The patch operation to be executed
	Op PatchOperationResultOp `json:"op"`

	// Path The attribute id for the patch operation
	Path string `json:"path"`

	// Result The result of the operation
	Result PatchOperationResultResult `json:"result"`

	// Value The values to update for the resource
	Value *string `json:"value,omitempty"`
}

// PatchOperationResultOp The patch operation to be executed
type PatchOperationResultOp string

// PatchOperationResultResult The result of the operation
type PatchOperationResultResult string

// PatchSingleAttributeReqModel defines model for PatchSingleAttributeReqModel.
type PatchSingleAttributeReqModel struct {
	// CredName The name of the attribute in the login session credentials. Maximum length is 2048 characters
	CredName *string `json:"credName,omitempty"`

	// CredNameOverrides Realm specific name of the attribute in the login session credentials. This property is specified in the form of key-value pairs where the key is the name of the realm  and the value is the name of the attribute used to override the 'credName' property. Maximum length is 2048 characters
	CredNameOverrides *map[string]string `json:"credNameOverrides,omitempty"`

	// CustomProperties Identifies the attribute custom properties that is attached to this attribute. These custom properties can be any user-defined key-value pairs that help identify or categorize the attribute. The maximum number of custom properties that can be defined is 25
	CustomProperties *map[string]string `json:"customProperties,omitempty"`

	// Datatype The type of derived data that is expected for the attribute. Defaults to string
	Datatype *PatchSingleAttributeReqModelDatatype `json:"datatype,omitempty"`

	// Description The description of the attribute. Maximum length is 2048 characters
	Description *string   `json:"description,omitempty"`
	Function    *Function `json:"function,omitempty"`

	// Name The human-readable name of the attribute. Maximum length is 2048 characters
	Name *string `json:"name,omitempty"`

	// SourceType The type of the attribute source from which the attribute value is derived
	SourceType *PatchSingleAttributeReqModelSourceType `json:"sourceType,omitempty"`

	// Tags The tags used to categorize attributes. Maximum number of tags is 25
	Tags *[]string `json:"tags,omitempty"`

	// Value The default value of the attribute. This value also refers to the fixed value for sourceType="static". Maximum length is 2048 characters
	Value *string `json:"value,omitempty"`
}

// PatchSingleAttributeReqModelDatatype The type of derived data that is expected for the attribute. Defaults to string
type PatchSingleAttributeReqModelDatatype string

// PatchSingleAttributeReqModelSourceType The type of the attribute source from which the attribute value is derived
type PatchSingleAttributeReqModelSourceType string

// PlanIdentifierTuple defines model for PlanIdentifierTuple.
type PlanIdentifierTuple struct {
	PlanID  *string `json:"planId,omitempty"`
	Set     *bool   `json:"set,omitempty"`
	Version *int32  `json:"version,omitempty"`
}

// PlanPackage defines model for PlanPackage.
type PlanPackage struct {
	AffectedPlans             *map[string][]PlanIdentifierTuple  `json:"affectedPlans,omitempty"`
	APIDescription            *string                            `json:"apiDescription,omitempty"`
	APIEndpoint               *string                            `json:"apiEndpoint,omitempty"`
	APIID                     *string                            `json:"apiId,omitempty"`
	APIName                   *string                            `json:"apiName,omitempty"`
	APIVersion                *string                            `json:"apiVersion,omitempty"`
	CreatedAt                 *time.Time                         `json:"createdAt,omitempty"`
	CreatedBy                 *string                            `json:"createdBy,omitempty"`
	Dependents                *map[string][]PlanPackage          `json:"dependents,omitempty"`
	DeploymentPackageID       *string                            `json:"deploymentPackageId,omitempty"`
	DeploymentState           *PlanPackageDeploymentState        `json:"deploymentState,omitempty"`
	DeploymentVisibility      *DeploymentVisibility              `json:"deploymentVisibility,omitempty"`
	Document                  *ConfigDataObject                  `json:"document,omitempty"`
	DocumentID                *string                            `json:"documentId,omitempty"`
	DocumentType              *PlanPackageDocumentType           `json:"documentType,omitempty"`
	DocumentVersion           *int32                             `json:"documentVersion,omitempty"`
	EnvID                     *string                            `json:"envId,omitempty"`
	ID                        *string                            `json:"id,omitempty"`
	OperationStatusSummary    *OperationStatusSummary            `json:"operationStatusSummary,omitempty"`
	OrgID                     *string                            `json:"orgId,omitempty"`
	PendingDeploymentState    *PlanPackagePendingDeploymentState `json:"pendingDeploymentState,omitempty"`
	PlanDescription           *string                            `json:"planDescription,omitempty"`
	PlanDisplayName           *string                            `json:"planDisplayName,omitempty"`
	PlanID                    *string                            `json:"planId,omitempty"`
	PlanName                  *string                            `json:"planName,omitempty"`
	PlanRegistrations         *int64                             `json:"planRegistrations,omitempty"`
	PlanRequiresApproval      *bool                              `json:"planRequiresApproval,omitempty"`
	PlanVersion               *int32                             `json:"planVersion,omitempty"`
	ProductName               *string                            `json:"productName,omitempty"`
	ProductVersion            *string                            `json:"productVersion,omitempty"`
	ProductVisibilityMetadata *ProductPackageUpdateJSONBody      `json:"productVisibilityMetadata,omitempty"`
	SupersededBy              *PlanIdentifierTuple               `json:"supersededBy,omitempty"`
	Supersedes                *PlanIdentifierTuple               `json:"supersedes,omitempty"`
	Task                      *TaskListGetResponse               `json:"task,omitempty"`
	TaskID                    *string                            `json:"taskId,omitempty"`
	UpdatedAt                 *time.Time                         `json:"updatedAt,omitempty"`
	UpdatedBy                 *string                            `json:"updatedBy,omitempty"`
	URL                       *string                            `json:"url,omitempty"`
	VendorExtensions          *map[string]map[string]interface{} `json:"vendorExtensions,omitempty"`
}

// PlanPackageDeploymentState defines model for PlanPackage.DeploymentState.
type PlanPackageDeploymentState string

// PlanPackageDocumentType defines model for PlanPackage.DocumentType.
type PlanPackageDocumentType string

// PlanPackagePendingDeploymentState defines model for PlanPackage.PendingDeploymentState.
type PlanPackagePendingDeploymentState string

// PrintWriter defines model for PrintWriter.
type PrintWriter = map[string]interface{}

// ProductPackageUpdateJSONBody defines model for ProductPackageUpdateJsonBody.
type ProductPackageUpdateJSONBody struct {
	Visibility *DeploymentVisibility `json:"visibility,omitempty"`
}

// ProfileAttribute defines model for ProfileAttribute.
type ProfileAttribute struct {
	// Name The name of the attribute in the application profile.
	Name string `json:"name"`
}

// ResultSet defines model for ResultSet.
type ResultSet struct {
	AfterLast      *bool              `json:"afterLast,omitempty"`
	BeforeFirst    *bool              `json:"beforeFirst,omitempty"`
	Closed         *bool              `json:"closed,omitempty"`
	Concurrency    *int32             `json:"concurrency,omitempty"`
	CursorName     *string            `json:"cursorName,omitempty"`
	FetchDirection *int32             `json:"fetchDirection,omitempty"`
	FetchSize      *int32             `json:"fetchSize,omitempty"`
	First          *bool              `json:"first,omitempty"`
	Holdability    *int32             `json:"holdability,omitempty"`
	Last           *bool              `json:"last,omitempty"`
	MetaData       *ResultSetMetaData `json:"metaData,omitempty"`
	Row            *int32             `json:"row,omitempty"`
	Statement      *Statement         `json:"statement,omitempty"`
	Type           *int32             `json:"type,omitempty"`
	Warnings       *SQLWarning        `json:"warnings,omitempty"`
}

// ResultSetMetaData defines model for ResultSetMetaData.
type ResultSetMetaData struct {
	ColumnCount *int32 `json:"columnCount,omitempty"`
}

// SQLException defines model for SQLException.
type SQLException struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	ErrorCode        *int32               `json:"errorCode,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	NextException    *SQLException        `json:"nextException,omitempty"`
	Sqlstate         *string              `json:"sqlstate,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// SQLWarning defines model for SQLWarning.
type SQLWarning struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	ErrorCode        *int32               `json:"errorCode,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	NextException    *SQLException        `json:"nextException,omitempty"`
	NextWarning      *SQLWarning          `json:"nextWarning,omitempty"`
	Sqlstate         *string              `json:"sqlstate,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// SchemaAttribute defines model for SchemaAttribute.
type SchemaAttribute struct {
	// AttributeName The attribute name in the schema that is associated with the attribute source
	AttributeName string `json:"attributeName"`

	// CustomAttribute The flag that indicates whether this is a custom attribute
	CustomAttribute bool `json:"customAttribute"`

	// Name The unique name for the attribute in the Cloud Directory schema. For custom schema attributes, the names are predefined and named customAttribute1 through customAttribute150
	Name string `json:"name"`

	// ScimName The SCIM name that is associated with the schema attribute
	ScimName string `json:"scimName"`
}

// ServletContext defines model for ServletContext.
type ServletContext struct {
	AttributeNames                *EnumerationString                             `json:"attributeNames,omitempty"`
	ClassLoader                   *ClassLoader                                   `json:"classLoader,omitempty"`
	ContextPath                   *string                                        `json:"contextPath,omitempty"`
	DefaultSessionTrackingModes   *[]ServletContextDefaultSessionTrackingModes   `json:"defaultSessionTrackingModes,omitempty"`
	EffectiveMajorVersion         *int32                                         `json:"effectiveMajorVersion,omitempty"`
	EffectiveMinorVersion         *int32                                         `json:"effectiveMinorVersion,omitempty"`
	EffectiveSessionTrackingModes *[]ServletContextEffectiveSessionTrackingModes `json:"effectiveSessionTrackingModes,omitempty"`
	FilterRegistrations           *map[string]FilterRegistration                 `json:"filterRegistrations,omitempty"`
	InitParameterNames            *EnumerationString                             `json:"initParameterNames,omitempty"`
	JspConfigDescriptor           *JspConfigDescriptor                           `json:"jspConfigDescriptor,omitempty"`
	MajorVersion                  *int32                                         `json:"majorVersion,omitempty"`
	MinorVersion                  *int32                                         `json:"minorVersion,omitempty"`
	ServerInfo                    *string                                        `json:"serverInfo,omitempty"`
	ServletContextName            *string                                        `json:"servletContextName,omitempty"`
	ServletNames                  *EnumerationString                             `json:"servletNames,omitempty"`
	ServletRegistrations          *map[string]ServletRegistration                `json:"servletRegistrations,omitempty"`
	Servlets                      *EnumerationServlet                            `json:"servlets,omitempty"`
	SessionCookieConfig           *SessionCookieConfig                           `json:"sessionCookieConfig,omitempty"`
	VirtualServerName             *string                                        `json:"virtualServerName,omitempty"`
}

// ServletContextDefaultSessionTrackingModes defines model for ServletContext.DefaultSessionTrackingModes.
type ServletContextDefaultSessionTrackingModes string

// ServletContextEffectiveSessionTrackingModes defines model for ServletContext.EffectiveSessionTrackingModes.
type ServletContextEffectiveSessionTrackingModes string

// ServletInputStream defines model for ServletInputStream.
type ServletInputStream struct {
	Finished *bool `json:"finished,omitempty"`
	Ready    *bool `json:"ready,omitempty"`
}

// ServletOutputStream defines model for ServletOutputStream.
type ServletOutputStream struct {
	Ready *bool `json:"ready,omitempty"`
}

// ServletRegistration defines model for ServletRegistration.
type ServletRegistration struct {
	ClassName      *string            `json:"className,omitempty"`
	InitParameters *map[string]string `json:"initParameters,omitempty"`
	Mappings       *[]string          `json:"mappings,omitempty"`
	Name           *string            `json:"name,omitempty"`
	RunAsRole      *string            `json:"runAsRole,omitempty"`
}

// ServletRequest defines model for ServletRequest.
type ServletRequest struct {
	AsyncContext      *AsyncContext                 `json:"asyncContext,omitempty"`
	AsyncStarted      *bool                         `json:"asyncStarted,omitempty"`
	AsyncSupported    *bool                         `json:"asyncSupported,omitempty"`
	AttributeNames    *EnumerationString            `json:"attributeNames,omitempty"`
	CharacterEncoding *string                       `json:"characterEncoding,omitempty"`
	ContentLength     *int32                        `json:"contentLength,omitempty"`
	ContentLengthLong *int64                        `json:"contentLengthLong,omitempty"`
	ContentType       *string                       `json:"contentType,omitempty"`
	DispatcherType    *ServletRequestDispatcherType `json:"dispatcherType,omitempty"`
	InputStream       *ServletInputStream           `json:"inputStream,omitempty"`
	LocalAddr         *string                       `json:"localAddr,omitempty"`
	LocalName         *string                       `json:"localName,omitempty"`
	LocalPort         *int32                        `json:"localPort,omitempty"`
	Locale            *Locale                       `json:"locale,omitempty"`
	Locales           *EnumerationLocale            `json:"locales,omitempty"`
	ParameterMap      *map[string][]string          `json:"parameterMap,omitempty"`
	ParameterNames    *EnumerationString            `json:"parameterNames,omitempty"`
	Protocol          *string                       `json:"protocol,omitempty"`
	Reader            *BufferedReader               `json:"reader,omitempty"`
	RemoteAddr        *string                       `json:"remoteAddr,omitempty"`
	RemoteHost        *string                       `json:"remoteHost,omitempty"`
	RemotePort        *int32                        `json:"remotePort,omitempty"`
	Scheme            *string                       `json:"scheme,omitempty"`
	Secure            *bool                         `json:"secure,omitempty"`
	ServerName        *string                       `json:"serverName,omitempty"`
	ServerPort        *int32                        `json:"serverPort,omitempty"`
	ServletContext    *ServletContext               `json:"servletContext,omitempty"`
}

// ServletRequestDispatcherType defines model for ServletRequest.DispatcherType.
type ServletRequestDispatcherType string

// ServletResponse defines model for ServletResponse.
type ServletResponse struct {
	BufferSize        *int32               `json:"bufferSize,omitempty"`
	CharacterEncoding *string              `json:"characterEncoding,omitempty"`
	Committed         *bool                `json:"committed,omitempty"`
	ContentType       *string              `json:"contentType,omitempty"`
	Locale            *Locale              `json:"locale,omitempty"`
	OutputStream      *ServletOutputStream `json:"outputStream,omitempty"`
	Writer            *PrintWriter         `json:"writer,omitempty"`
}

// SessionCookieConfig defines model for SessionCookieConfig.
type SessionCookieConfig struct {
	Comment  *string `json:"comment,omitempty"`
	Domain   *string `json:"domain,omitempty"`
	HTTPOnly *bool   `json:"httpOnly,omitempty"`
	MaxAge   *int32  `json:"maxAge,omitempty"`
	Name     *string `json:"name,omitempty"`
	Path     *string `json:"path,omitempty"`
	Secure   *bool   `json:"secure,omitempty"`
}

// StackTraceElement defines model for StackTraceElement.
type StackTraceElement struct {
	ClassName    *string `json:"className,omitempty"`
	FileName     *string `json:"fileName,omitempty"`
	LineNumber   *int32  `json:"lineNumber,omitempty"`
	MethodName   *string `json:"methodName,omitempty"`
	NativeMethod *bool   `json:"nativeMethod,omitempty"`
}

// Statement defines model for Statement.
type Statement struct {
	CloseOnCompletion    *bool       `json:"closeOnCompletion,omitempty"`
	Closed               *bool       `json:"closed,omitempty"`
	Connection           *Connection `json:"connection,omitempty"`
	FetchDirection       *int32      `json:"fetchDirection,omitempty"`
	FetchSize            *int32      `json:"fetchSize,omitempty"`
	GeneratedKeys        *ResultSet  `json:"generatedKeys,omitempty"`
	LargeMaxRows         *int64      `json:"largeMaxRows,omitempty"`
	LargeUpdateCount     *int64      `json:"largeUpdateCount,omitempty"`
	MaxFieldSize         *int32      `json:"maxFieldSize,omitempty"`
	MaxRows              *int32      `json:"maxRows,omitempty"`
	MoreResults          *bool       `json:"moreResults,omitempty"`
	Poolable             *bool       `json:"poolable,omitempty"`
	QueryTimeout         *int32      `json:"queryTimeout,omitempty"`
	ResultSet            *ResultSet  `json:"resultSet,omitempty"`
	ResultSetConcurrency *int32      `json:"resultSetConcurrency,omitempty"`
	ResultSetHoldability *int32      `json:"resultSetHoldability,omitempty"`
	ResultSetType        *int32      `json:"resultSetType,omitempty"`
	UpdateCount          *int32      `json:"updateCount,omitempty"`
	Warnings             *SQLWarning `json:"warnings,omitempty"`
}

// Subscribe defines model for Subscribe.
type Subscribe struct {
	// Enabled Is the plan visible.
	Enabled bool `json:"enabled"`

	// Orgs When subscribe is custom: The Organizations allowed to subscribe.
	Orgs *[]string `json:"orgs,omitempty"`

	// Tags When subscribe is custom: The Communities allowed to subscribe.
	Tags *[]string     `json:"tags,omitempty"`
	Type SubscribeType `json:"type"`
}

// SubscribeType defines model for Subscribe.Type.
type SubscribeType string

// TaglibDescriptor defines model for TaglibDescriptor.
type TaglibDescriptor struct {
	TaglibLocation *string `json:"taglibLocation,omitempty"`
	TaglibURI      *string `json:"taglibURI,omitempty"`
}

// TaskActivityResponse defines model for TaskActivityResponse.
type TaskActivityResponse struct {
	// Action The action executed by this activity
	Action *map[string]interface{} `json:"action,omitempty"`

	// Comment The user's comment for this action
	Comment *string `json:"comment,omitempty"`

	// Date The date this action was executed
	Date *time.Time `json:"date,omitempty"`

	// DisplayName The display name of the user who initiated this action
	DisplayName *string `json:"displayName,omitempty"`

	// UserID The id of the user who initiated this action
	UserID *string `json:"userId,omitempty"`

	// Username The username of the user who initiated this action
	Username *string `json:"username,omitempty"`
}

// TaskListGetResponse defines model for TaskListGetResponse.
type TaskListGetResponse struct {
	Activities       []TaskActivityResponse      `json:"activities"`
	AvailableActions []string                    `json:"availableActions"`
	EnvID            string                      `json:"envId"`
	ID               string                      `json:"id"`
	OrgID            string                      `json:"orgId"`
	Status           TaskListGetResponseStatus   `json:"status"`
	TaskProperties   *string                     `json:"taskProperties,omitempty"`
	TaskType         TaskListGetResponseTaskType `json:"taskType"`
	URL              string                      `json:"url"`
}

// TaskListGetResponseStatus defines model for TaskListGetResponse.Status.
type TaskListGetResponseStatus string

// TaskListGetResponseTaskType defines model for TaskListGetResponse.TaskType.
type TaskListGetResponseTaskType string

// TemplateError defines model for TemplateError.
type TemplateError struct {
	MessageDescription *string `json:"messageDescription,omitempty"`
	MessageID          *string `json:"messageId,omitempty"`
}

// TemporalUnit defines model for TemporalUnit.
type TemporalUnit struct {
	DateBased         *bool     `json:"dateBased,omitempty"`
	Duration          *Duration `json:"duration,omitempty"`
	DurationEstimated *bool     `json:"durationEstimated,omitempty"`
	TimeBased         *bool     `json:"timeBased,omitempty"`
}

// ThemeRegistrationPaginatedResponseContainer defines model for ThemeRegistrationPaginatedResponseContainer.
type ThemeRegistrationPaginatedResponseContainer struct {
	Count              *int32                    `json:"count,omitempty"`
	Limit              *int32                    `json:"limit,omitempty"`
	Page               *int32                    `json:"page,omitempty"`
	ThemeRegistrations *[]map[string]interface{} `json:"themeRegistrations,omitempty"`
	Total              *int32                    `json:"total,omitempty"`
}

// Throwable defines model for Throwable.
type Throwable struct {
	Cause            *Throwable           `json:"cause,omitempty"`
	LocalizedMessage *string              `json:"localizedMessage,omitempty"`
	Message          *string              `json:"message,omitempty"`
	StackTrace       *[]StackTraceElement `json:"stackTrace,omitempty"`
	Suppressed       *[]Throwable         `json:"suppressed,omitempty"`
}

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	// ActorToken The token identifying the acting party in a token exchange flow.
	ActorToken *string `json:"actor_token,omitempty"`

	// ActorTokenType The token type of the actor_token.
	ActorTokenType *interface{} `json:"actor_token_type,omitempty"`

	// ClientAssertion The JWT assertion being used to authenticate the client.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType The format of client assertion.
	ClientAssertionType *TokenRequestClientAssertionType `json:"client_assertion_type,omitempty"`

	// ClientID The OIDC client ID that is required when the basic authorization header is not set.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret The OIDC client secret that is required when the basic authorization header is not set and the client is not a public client.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Code The authorization code. It is only required for "authorization_code" grant types.
	Code *string `json:"code,omitempty"`

	// CodeVerifier The code verifier. This is used to verify the code challenge that was sent at the authorize endpoint. Required if the OIDC client is configured to require proof key for code exchange (PKCE)
	CodeVerifier *string `json:"code_verifier,omitempty"`

	// GrantType The grant type.
	GrantType TokenRequestGrantType `json:"grant_type"`

	// Password The password credential of resource owner. It is only required for "password" grant types.
	Password *string `json:"password,omitempty"`

	// RedirectURI The redirect URI. It is only required for "authorization_code" grant types.
	RedirectURI *string `json:"redirect_uri,omitempty"`

	// RefreshToken The refresh token. It is only required for "refresh_token" grant types.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// RequestedTokenType The type of token that should be returned as part of the token exchange flow.
	RequestedTokenType *string `json:"requested_token_type,omitempty"`

	// Scope A space-delimited list of scopes that are associated with generated access token.
	Scope *string `json:"scope,omitempty"`

	// SubjectToken The token identifying the subject for a token exchange flow.
	SubjectToken *string `json:"subject_token,omitempty"`

	// SubjectTokenType The token type of the subject_token.
	SubjectTokenType *string `json:"subject_token_type,omitempty"`

	// Username The user credential of resource owner. It is only required for "password" grant types.
	Username *string `json:"username,omitempty"`
}

// TokenRequestClientAssertionType The format of client assertion.
type TokenRequestClientAssertionType string

// TokenRequestGrantType The grant type.
type TokenRequestGrantType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// AccessToken The access token that is issued by the authorization server.
	AccessToken string `json:"access_token"`

	// ExpiresIn The lifetime, in seconds, of the access token.
	ExpiresIn int32 `json:"expires_in"`

	// GrantID The grant identifier of this authorization grant.
	GrantID string `json:"grant_id"`

	// IDToken The ID token that is issued by the authorization server, when the requested scope contains 'openid'.
	IDToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token that is used to obtain new access tokens. It is only available for authorization_code grant if the refresh_token grant is enabled.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope A space-delimited list of scopes that are associated with this access token.
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the access token.
	TokenType string `json:"token_type"`
}

// TransformBody TransformBody is either a valid UTF-8 string, or a valid JSON object
type TransformBody struct {
	JSON *map[string]map[string]interface{} `json:"JSON,omitempty"`
	Raw  *[]uint8                           `json:"Raw,omitempty"`
}

// TransformObject defines model for TransformObject.
type TransformObject struct {
	// AuthenticationHeader AuthenticationHeader is an outgoing transform parameter.
	AuthenticationHeader *map[string]string `json:"authentication_header,omitempty"`

	// Body TransformBody is either a valid UTF-8 string, or a valid JSON object
	Body *TransformBody `json:"body,omitempty"`

	// Header The keys should be in canonical form, as returned by
	// CanonicalHeaderKey.
	Header *Header `json:"header,omitempty"`

	// Host Host is an outgoing transform parameter, and will only be populated in webhook usage when all the URLs configured have a consistent host
	Host *string `json:"host,omitempty"`

	// Method Method is an outgoing transform parameter.
	Method *string `json:"method,omitempty"`

	// Path Path is an outgoing transform parameter.
	Path    *string          `json:"path,omitempty"`
	Request *TransformObject `json:"request,omitempty"`

	// StatusCode StatusCode is an incoming transform parameter.
	StatusCode *int64 `json:"statusCode,omitempty"`
}

// UserGroupV1 Represents a user group
type UserGroupV1 struct {
	Description *string `json:"description,omitempty"`
	Email       *string `json:"email,omitempty"`
	FamilyName  *string `json:"familyName,omitempty"`
	Formatted   *string `json:"formatted,omitempty"`
	GivenName   *string `json:"givenName,omitempty"`
	ID          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Realm       *string `json:"realm,omitempty"`
	UserType    *string `json:"userType,omitempty"`
}

// ValueConstraint defines model for ValueConstraint.
type ValueConstraint struct {
	Format *string                 `json:"format,omitempty"`
	Type   *string                 `json:"type,omitempty"`
	Value  *map[string]interface{} `json:"value,omitempty"`
}

// View defines model for View.
type View struct {
	// Enabled Is the plan visible.
	Enabled bool `json:"enabled"`

	// Orgs When view is custom: The Organizations allowed to view this plan.
	Orgs *[]string `json:"orgs,omitempty"`

	// Tags When view is custom: The Communities allowed to view this plan.
	Tags *[]string `json:"tags,omitempty"`
	Type ViewType  `json:"type"`
}

// ViewType defines model for View.Type.
type ViewType string

// PostOauth2TokenParams defines parameters for PostOauth2Token.
type PostOauth2TokenParams struct {
	// Authorization The basic authorization header that contains a base64-encoded client ID and the client secret. Use this header as an alternative to sending the client ID and secret in the form parameters.
	Authorization *string `json:"Authorization,omitempty"`
}

// GetAllAttributesParams defines parameters for GetAllAttributes.
type GetAllAttributesParams struct {
	// Search Returns results based on the search criteria.<br><br>The format to use the search query parameter is 'search={parameter}{operator}{value}<br><br>The following search parameters are allowed: name, credname, tags, sourcetype, id, scope.<br><br>Parameters name, credname, tags, sourcetype, id, scope only support search by string values.<br><br>Valid operators for string values are =, !=, contains, startswith, endswith, and exists.<br> Only for the 'exists' operator, there is no need to specify search value. <br> And for all rest operators, use double quotation marks for the search values.<br><br>Multiple search conditions can be combined using either the & (AND) or | (OR) operators.<br><br>Conditions in parentheses () have a higher priority and are evaluated first. Without parentheses, & (AND) is evaluated first.<br><b>Example</b>: (tags="sso"|name="email")&id="10"<br><b>Note</b>: Nested parentheses are not supported.<br><br><b>Example</b>: Search for attributes with 'sso' tag: search=tags="sso"<br><b>Example</b>: Search for attributes with name startwith 'pre': search=name%20startswith%20"pre"<br><b>Example</b>: Search for attributes with tag: search=tags%20exists<br>
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Returns sorted results.<br>The following sort parameters are allowed: name, credname, tags, sourcetype, scope.<br>Each sort parameter must be prefixed with either + or -.<br><br><b>Example</b>: Sort attributes by ascending 'name': sort=+name<br>
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Pagination Returns results based on the requested limit and page.<br>The following pagination parameters are allowed: limit, page.<br><br><b>Example</b>: Get only 5 results at the second page: pagination=limit=5%26page=2<br>
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// PatchAttributesParams defines parameters for PatchAttributes.
type PatchAttributesParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// CreateAttributeParams defines parameters for CreateAttribute.
type CreateAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// DeleteAttributeParams defines parameters for DeleteAttribute.
type DeleteAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// GetAttribute0Params defines parameters for GetAttribute0.
type GetAttribute0Params struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// PatchSingleAttributeParams defines parameters for PatchSingleAttribute.
type PatchSingleAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// UpdateAttributeParams defines parameters for UpdateAttribute.
type UpdateAttributeParams struct {
	// Authorization Authorization Header
	Authorization string `json:"Authorization"`
}

// GetThemeRegistrationsParams defines parameters for GetThemeRegistrations.
type GetThemeRegistrationsParams struct {
	// Pagination Controls the results that are returned in a page. If no pagination parameters are passed in all results are returned.<br><br>You can use the following query parameters:<br><br><b>count</b> - Use to define the total number of results that are returned from the data store. The maximum allowed value is 1000.<br><br><b>page</b> - Use to identify the requested page, or the offset.<br><br><b>limit</b> - Use to define the total number of results that are returned per page. The maximum allowed value is 1000.<br><br><b>Note</b>: If you are not using the Swagger UI, the pagination parameter value must be HTML encoded. Use the prefix "pagination=" in the query parameter.<br><br><b>Example</b>: Paginate on count=10&page=1&limit=5<br>pagination=count%3D10%26page%3D1%26limit%3D5
	Pagination *string `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// RegisterThemeTemplatesMultipartBody defines parameters for RegisterThemeTemplates.
type RegisterThemeTemplatesMultipartBody struct {
	// Configuration Theme Registration configuration payload. String-encoded JSON Object.<br><br>Example:<br>{<br>"name": "string",<br>"description": "string (optional)"<br>}<br><br>
	Configuration string `json:"configuration"`

	// Files Customized Template .zip File
	Files openapi_types.File `json:"files"`
}

// DownloadThemeTemplatesParams defines parameters for DownloadThemeTemplates.
type DownloadThemeTemplatesParams struct {
	// CustomizedOnly Includes templates that are customized only. Returns global templates if false
	CustomizedOnly *bool `form:"customized_only,omitempty" json:"customized_only,omitempty"`
}

// UpdateThemeTemplatesMultipartBody defines parameters for UpdateThemeTemplates.
type UpdateThemeTemplatesMultipartBody struct {
	// Configuration Theme Registration configuration payload. String-encoded JSON Object.<br><br>Example:<br>{<br>"name": "string",<br>"description": "string (optional)"<br>}<br><br>
	Configuration string `json:"configuration"`

	// Files Customized Theme .zip File
	Files *openapi_types.File `json:"files,omitempty"`
}

// PostOauth2TokenFormdataRequestBody defines body for PostOauth2Token for application/x-www-form-urlencoded ContentType.
type PostOauth2TokenFormdataRequestBody = TokenRequest

// RegisterThemeTemplatesMultipartRequestBody defines body for RegisterThemeTemplates for multipart/form-data ContentType.
type RegisterThemeTemplatesMultipartRequestBody RegisterThemeTemplatesMultipartBody

// UpdateThemeTemplatesMultipartRequestBody defines body for UpdateThemeTemplates for multipart/form-data ContentType.
type UpdateThemeTemplatesMultipartRequestBody UpdateThemeTemplatesMultipartBody

// Getter for additional properties for Header. Returns the specified
// element and whether it was found
func (a Header) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Header
func (a *Header) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Header to handle AdditionalProperties
func (a *Header) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Header to handle AdditionalProperties
func (a Header) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	if a.Value != nil {
		object["value"], err = json.Marshal(a.Value)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'value': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostOauth2TokenWithBody request with any body
	PostOauth2TokenWithBody(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOauth2TokenWithFormdataBody(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAttributes request
	GetAllAttributes(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAttributesWithBody request with any body
	PatchAttributesWithBody(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttributeWithBody request with any body
	CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttribute request
	DeleteAttribute(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttribute0 request
	GetAttribute0(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSingleAttributeWithBody request with any body
	PatchSingleAttributeWithBody(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttributeWithBody request with any body
	UpdateAttributeWithBody(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThemeRegistrations request
	GetThemeRegistrations(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterThemeTemplatesWithBody request with any body
	RegisterThemeTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeregisterTheme request
	DeregisterTheme(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadThemeTemplates request
	DownloadThemeTemplates(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThemeTemplatesWithBody request with any body
	UpdateThemeTemplatesWithBody(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostOauth2TokenWithBody(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithFormdataBody(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAttributes(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAttributesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAttributesWithBody(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAttributesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttribute(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttributeRequest(c.Server, attrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttribute0(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttribute0Request(c.Server, attrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSingleAttributeWithBody(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSingleAttributeRequestWithBody(c.Server, attrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributeWithBody(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributeRequestWithBody(c.Server, attrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThemeRegistrations(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThemeRegistrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterThemeTemplatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterThemeTemplatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeregisterTheme(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeregisterThemeRequest(c.Server, themeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadThemeTemplates(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadThemeTemplatesRequest(c.Server, themeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThemeTemplatesWithBody(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThemeTemplatesRequestWithBody(c.Server, themeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostOauth2TokenRequestWithFormdataBody calls the generic PostOauth2Token builder with application/x-www-form-urlencoded body
func NewPostOauth2TokenRequestWithFormdataBody(server string, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOauth2TokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOauth2TokenRequestWithBody generates requests for PostOauth2Token with any type of body
func NewPostOauth2TokenRequestWithBody(server string, params *PostOauth2TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetAllAttributesRequest generates requests for GetAllAttributes
func NewGetAllAttributesRequest(server string, params *GetAllAttributesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewPatchAttributesRequestWithBody generates requests for PatchAttributes with any type of body
func NewPatchAttributesRequestWithBody(server string, params *PatchAttributesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewCreateAttributeRequestWithBody generates requests for CreateAttribute with any type of body
func NewCreateAttributeRequestWithBody(server string, params *CreateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDeleteAttributeRequest generates requests for DeleteAttribute
func NewDeleteAttributeRequest(server string, attrID string, params *DeleteAttributeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetAttribute0Request generates requests for GetAttribute0
func NewGetAttribute0Request(server string, attrID string, params *GetAttribute0Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewPatchSingleAttributeRequestWithBody generates requests for PatchSingleAttribute with any type of body
func NewPatchSingleAttributeRequestWithBody(server string, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewUpdateAttributeRequestWithBody generates requests for UpdateAttribute with any type of body
func NewUpdateAttributeRequestWithBody(server string, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attrId", runtime.ParamLocationPath, attrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetThemeRegistrationsRequest generates requests for GetThemeRegistrations
func NewGetThemeRegistrationsRequest(server string, params *GetThemeRegistrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterThemeTemplatesRequestWithBody generates requests for RegisterThemeTemplates with any type of body
func NewRegisterThemeTemplatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeregisterThemeRequest generates requests for DeregisterTheme
func NewDeregisterThemeRequest(server string, themeID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadThemeTemplatesRequest generates requests for DownloadThemeTemplates
func NewDownloadThemeTemplatesRequest(server string, themeID string, params *DownloadThemeTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomizedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customized_only", runtime.ParamLocationQuery, *params.CustomizedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateThemeTemplatesRequestWithBody generates requests for UpdateThemeTemplates with any type of body
func NewUpdateThemeTemplatesRequestWithBody(server string, themeID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "themeId", runtime.ParamLocationPath, themeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1.0/branding/themes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostOauth2TokenWithBodyWithResponse request with any body
	PostOauth2TokenWithBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error)

	PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error)

	// GetAllAttributesWithResponse request
	GetAllAttributesWithResponse(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*GetAllAttributesObject, error)

	// PatchAttributesWithBodyWithResponse request with any body
	PatchAttributesWithBodyWithResponse(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAttributesObject, error)

	// CreateAttributeWithBodyWithResponse request with any body
	CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeObject, error)

	// DeleteAttributeWithResponse request
	DeleteAttributeWithResponse(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeObject, error)

	// GetAttribute0WithResponse request
	GetAttribute0WithResponse(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*GetAttribute0Object, error)

	// PatchSingleAttributeWithBodyWithResponse request with any body
	PatchSingleAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSingleAttributeObject, error)

	// UpdateAttributeWithBodyWithResponse request with any body
	UpdateAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeObject, error)

	// GetThemeRegistrationsWithResponse request
	GetThemeRegistrationsWithResponse(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*GetThemeRegistrationsObject, error)

	// RegisterThemeTemplatesWithBodyWithResponse request with any body
	RegisterThemeTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterThemeTemplatesObject, error)

	// DeregisterThemeWithResponse request
	DeregisterThemeWithResponse(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*DeregisterThemeObject, error)

	// DownloadThemeTemplatesWithResponse request
	DownloadThemeTemplatesWithResponse(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*DownloadThemeTemplatesObject, error)

	// UpdateThemeTemplatesWithBodyWithResponse request with any body
	UpdateThemeTemplatesWithBodyWithResponse(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplatesObject, error)
}

type PostOauth2TokenObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *Error0
	JSON500      *Error0
}

// Status returns HTTPResponse.Status
func (r PostOauth2TokenObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOauth2TokenObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAttributesObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Attribute0
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r GetAllAttributesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAttributesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAttributesObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *PatchOperationResponse
	JSON400      *PatchOperationResponse
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r PatchAttributesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAttributesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r CreateAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r DeleteAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttribute0Object struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *ErrorBean
	JSON404 *ErrorBean
	JSON500 *ErrorBean
}

// Status returns HTTPResponse.Status
func (r GetAttribute0Object) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttribute0Object) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSingleAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r PatchSingleAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSingleAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttributeObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBean
	JSON404      *ErrorBean
	JSON500      *ErrorBean
}

// Status returns HTTPResponse.Status
func (r UpdateAttributeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttributeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThemeRegistrationsObject struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThemeRegistrationPaginatedResponseContainer
	JSON400      *TemplateError
	JSON401      *TemplateError
	JSON403      *TemplateError
	JSON404      *TemplateError
	JSON405      *TemplateError
	JSON406      *TemplateError
	JSON415      *TemplateError
	JSON500      *TemplateError
}

// Status returns HTTPResponse.Status
func (r GetThemeRegistrationsObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThemeRegistrationsObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeregisterThemeObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeregisterThemeObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeregisterThemeObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThemeTemplatesObject struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThemeTemplatesObject) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThemeTemplatesObject) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostOauth2TokenWithBodyWithResponse request with arbitrary body returning *PostOauth2TokenObject
func (c *ClientWithResponses) PostOauth2TokenWithBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error) {
	rsp, err := c.PostOauth2TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenObject(rsp)
}

func (c *ClientWithResponses) PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth2TokenParams, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenObject, error) {
	rsp, err := c.PostOauth2TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenObject(rsp)
}

// GetAllAttributesWithResponse request returning *GetAllAttributesObject
func (c *ClientWithResponses) GetAllAttributesWithResponse(ctx context.Context, params *GetAllAttributesParams, reqEditors ...RequestEditorFn) (*GetAllAttributesObject, error) {
	rsp, err := c.GetAllAttributes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAttributesObject(rsp)
}

// PatchAttributesWithBodyWithResponse request with arbitrary body returning *PatchAttributesObject
func (c *ClientWithResponses) PatchAttributesWithBodyWithResponse(ctx context.Context, params *PatchAttributesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAttributesObject, error) {
	rsp, err := c.PatchAttributesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAttributesObject(rsp)
}

// CreateAttributeWithBodyWithResponse request with arbitrary body returning *CreateAttributeObject
func (c *ClientWithResponses) CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeObject, error) {
	rsp, err := c.CreateAttributeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributeObject(rsp)
}

// DeleteAttributeWithResponse request returning *DeleteAttributeObject
func (c *ClientWithResponses) DeleteAttributeWithResponse(ctx context.Context, attrID string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeObject, error) {
	rsp, err := c.DeleteAttribute(ctx, attrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttributeObject(rsp)
}

// GetAttribute0WithResponse request returning *GetAttribute0Object
func (c *ClientWithResponses) GetAttribute0WithResponse(ctx context.Context, attrID string, params *GetAttribute0Params, reqEditors ...RequestEditorFn) (*GetAttribute0Object, error) {
	rsp, err := c.GetAttribute0(ctx, attrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttribute0Object(rsp)
}

// PatchSingleAttributeWithBodyWithResponse request with arbitrary body returning *PatchSingleAttributeObject
func (c *ClientWithResponses) PatchSingleAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *PatchSingleAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSingleAttributeObject, error) {
	rsp, err := c.PatchSingleAttributeWithBody(ctx, attrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSingleAttributeObject(rsp)
}

// UpdateAttributeWithBodyWithResponse request with arbitrary body returning *UpdateAttributeObject
func (c *ClientWithResponses) UpdateAttributeWithBodyWithResponse(ctx context.Context, attrID string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeObject, error) {
	rsp, err := c.UpdateAttributeWithBody(ctx, attrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributeObject(rsp)
}

// GetThemeRegistrationsWithResponse request returning *GetThemeRegistrationsObject
func (c *ClientWithResponses) GetThemeRegistrationsWithResponse(ctx context.Context, params *GetThemeRegistrationsParams, reqEditors ...RequestEditorFn) (*GetThemeRegistrationsObject, error) {
	rsp, err := c.GetThemeRegistrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThemeRegistrationsObject(rsp)
}

// RegisterThemeTemplatesWithBodyWithResponse request with arbitrary body returning *RegisterThemeTemplatesObject
func (c *ClientWithResponses) RegisterThemeTemplatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterThemeTemplatesObject, error) {
	rsp, err := c.RegisterThemeTemplatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterThemeTemplatesObject(rsp)
}

// DeregisterThemeWithResponse request returning *DeregisterThemeObject
func (c *ClientWithResponses) DeregisterThemeWithResponse(ctx context.Context, themeID string, reqEditors ...RequestEditorFn) (*DeregisterThemeObject, error) {
	rsp, err := c.DeregisterTheme(ctx, themeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeregisterThemeObject(rsp)
}

// DownloadThemeTemplatesWithResponse request returning *DownloadThemeTemplatesObject
func (c *ClientWithResponses) DownloadThemeTemplatesWithResponse(ctx context.Context, themeID string, params *DownloadThemeTemplatesParams, reqEditors ...RequestEditorFn) (*DownloadThemeTemplatesObject, error) {
	rsp, err := c.DownloadThemeTemplates(ctx, themeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadThemeTemplatesObject(rsp)
}

// UpdateThemeTemplatesWithBodyWithResponse request with arbitrary body returning *UpdateThemeTemplatesObject
func (c *ClientWithResponses) UpdateThemeTemplatesWithBodyWithResponse(ctx context.Context, themeID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThemeTemplatesObject, error) {
	rsp, err := c.UpdateThemeTemplatesWithBody(ctx, themeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThemeTemplatesObject(rsp)
}

// ParsePostOauth2TokenObject parses an HTTP response from a PostOauth2TokenWithResponse call
func ParsePostOauth2TokenObject(rsp *http.Response) (*PostOauth2TokenObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOauth2TokenObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAttributesObject parses an HTTP response from a GetAllAttributesWithResponse call
func ParseGetAllAttributesObject(rsp *http.Response) (*GetAllAttributesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAttributesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Attribute0
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchAttributesObject parses an HTTP response from a PatchAttributesWithResponse call
func ParsePatchAttributesObject(rsp *http.Response) (*PatchAttributesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAttributesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest PatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAttributeObject parses an HTTP response from a CreateAttributeWithResponse call
func ParseCreateAttributeObject(rsp *http.Response) (*CreateAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAttributeObject parses an HTTP response from a DeleteAttributeWithResponse call
func ParseDeleteAttributeObject(rsp *http.Response) (*DeleteAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttribute0Object parses an HTTP response from a GetAttribute0WithResponse call
func ParseGetAttribute0Object(rsp *http.Response) (*GetAttribute0Object, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttribute0Object{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSingleAttributeObject parses an HTTP response from a PatchSingleAttributeWithResponse call
func ParsePatchSingleAttributeObject(rsp *http.Response) (*PatchSingleAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSingleAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttributeObject parses an HTTP response from a UpdateAttributeWithResponse call
func ParseUpdateAttributeObject(rsp *http.Response) (*UpdateAttributeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttributeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThemeRegistrationsObject parses an HTTP response from a GetThemeRegistrationsWithResponse call
func ParseGetThemeRegistrationsObject(rsp *http.Response) (*GetThemeRegistrationsObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThemeRegistrationsObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThemeRegistrationPaginatedResponseContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest TemplateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterThemeTemplatesObject parses an HTTP response from a RegisterThemeTemplatesWithResponse call
func ParseRegisterThemeTemplatesObject(rsp *http.Response) (*RegisterThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeregisterThemeObject parses an HTTP response from a DeregisterThemeWithResponse call
func ParseDeregisterThemeObject(rsp *http.Response) (*DeregisterThemeObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeregisterThemeObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadThemeTemplatesObject parses an HTTP response from a DownloadThemeTemplatesWithResponse call
func ParseDownloadThemeTemplatesObject(rsp *http.Response) (*DownloadThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThemeTemplatesObject parses an HTTP response from a UpdateThemeTemplatesWithResponse call
func ParseUpdateThemeTemplatesObject(rsp *http.Response) (*UpdateThemeTemplatesObject, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThemeTemplatesObject{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
